<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expert_op4grid Standalone Interface</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <!-- svg-pan-zoom removed -->
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .config-panel {
            background: #f4f4f4;
            padding: 15px;
            border-bottom: 1px solid #ccc;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: end;
        }

        .config-panel input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .action-feed {
            width: 25%;
            background: #eee;
            border-right: 1px solid #ccc;
            padding: 15px;
            overflow-y: auto;
        }

        .visualization {
            flex: 1;
            background: white;
            position: relative;
        }

        .card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #dc3545;
        }

        .card h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }

        button {
            padding: 8px 15px;
            cursor: pointer;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }


        .svg-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .svg-container svg {
            width: 100%;
            height: 100%;
        }

        /* Keep lines/paths visible at any zoom level without breaking fills/colors */
        .svg-container svg path,
        .svg-container svg line,
        .svg-container svg polyline,
        .svg-container svg rect {
            vector-effect: non-scaling-stroke;
        }

        .error {
            color: red;
            margin-top: 5px;
            font-size: 12px;
        }

        /* Highlight styles: persistent and simple */
        .nad-highlight {
            stroke: #e74c3c !important;
            stroke-width: 4px !important;
            opacity: 0.9;
        }

        circle.nad-highlight {
            fill: #e74c3c !important;
        }

        /* Highlight overloaded lines in orange */
        .nad-overloaded path,
        .nad-overloaded line,
        .nad-overloaded polyline {
            stroke: #ff8c00 !important;
            stroke-width: 3px !important;
        }

        /* Highlight lines acted upon by the selected action in yellow fluo */
        .nad-action-target path,
        .nad-action-target line,
        .nad-action-target polyline {
            stroke: #ccff00 !important;
            stroke-width: 3px !important;
        }

        /* Hide text on large grids at full zoom — revealed by removing this class.
           display:none removes elements from layout entirely, so the browser
           skips layout/paint for thousands of text nodes at initial load. */
        .svg-container.text-hidden foreignObject,
        .svg-container.text-hidden .nad-edge-infos,
        .svg-container.text-hidden .nad-text-edges {
            display: none !important;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useLayoutEffect, useMemo, Fragment, useRef } = React;
        const API_BASE = 'http://localhost:8000';

        // Custom Hook for SVG Pan/Zoom logic
        // Performance: viewBox updates go directly to the DOM via refs,
        // bypassing React's render cycle during active interaction.
        // React state is only synced on interaction end / pause.
        const usePanZoom = (svgRef, initialViewBox, active) => {
            // React state: "settled" viewBox for downstream consumers
            const [viewBox, setViewBox] = useState(null);
            // Mutable ref for the hot path — updated every frame, no React render
            const viewBoxRef = useRef(null);
            const isDragging = useRef(false);
            const startPoint = useRef({ x: 0, y: 0 });
            const wheelTimerId = useRef(null);
            const rafId = useRef(null);
            // Cached SVG element ref — avoids querySelector on every event
            const svgElRef = useRef(null);
            const activeRef = useRef(active);
            activeRef.current = active;
            // Original viewBox max dimension — used for relative text visibility threshold
            const initialMaxDimRef = useRef(null);

            // Direct DOM update — no React involved
            const applyViewBox = (vb) => {
                const svg = svgElRef.current;
                if (svg && vb) {
                    svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
                }
                // Toggle text visibility based on zoom level (large grids only).
                // Show text when zoomed in to < 50% of original viewBox (2x+ zoom).
                // This scales with grid size: zoomToElement typically zooms to
                // 10-30% of the grid, so text always appears on element focus.
                const container = svgRef.current;
                if (container && vb && svg && svg.hasAttribute('data-large-grid')) {
                    const origMax = initialMaxDimRef.current;
                    const shouldHide = !origMax || Math.max(vb.w, vb.h) / origMax >= 0.5;
                    container.classList.toggle('text-hidden', shouldHide);
                }
            };

            // Flush ref -> React state for downstream consumers
            const commitViewBox = () => {
                if (viewBoxRef.current) {
                    setViewBox({ ...viewBoxRef.current });
                }
            };

            // Cache SVG element when container content changes.
            // Also hide text immediately on large grids to prevent a flash
            // of unreadable text before the first applyViewBox call.
            useLayoutEffect(() => {
                if (svgRef.current) {
                    svgElRef.current = svgRef.current.querySelector('svg');
                    if (svgElRef.current && svgElRef.current.hasAttribute('data-large-grid')) {
                        const vb = viewBoxRef.current;
                        const origMax = initialMaxDimRef.current;
                        if (!vb || !origMax || Math.max(vb.w, vb.h) / origMax >= 0.5) {
                            svgRef.current.classList.add('text-hidden');
                        }
                    }
                } else {
                    svgElRef.current = null;
                }
            });

            // Sync from initialViewBox (diagram load or programmatic reset)
            useEffect(() => {
                if (initialViewBox) {
                    viewBoxRef.current = initialViewBox;
                    initialMaxDimRef.current = Math.max(initialViewBox.w, initialViewBox.h);
                    applyViewBox(initialViewBox);
                    setViewBox(initialViewBox);
                    // Diagnostic: log effective scaling
                    const el = svgRef.current;
                    if (el) {
                        const rect = el.getBoundingClientRect();
                        const scaleX = rect.width / initialViewBox.w;
                        const scaleY = rect.height / initialViewBox.h;
                        console.log(`[SVG render] container=${rect.width.toFixed(0)}x${rect.height.toFixed(0)}, viewBox=${initialViewBox.w.toFixed(0)}x${initialViewBox.h.toFixed(0)}, scale=${Math.min(scaleX, scaleY).toFixed(3)}`);
                    }
                }
            }, [initialViewBox]);

            const handleWheel = (e) => {
                if (!activeRef.current || !viewBoxRef.current) return;
                e.preventDefault();
                const vb = viewBoxRef.current;
                const scaleFactor = e.deltaY > 0 ? 1.1 : 0.9;

                const svg = svgElRef.current;
                if (!svg) return;

                const pt = svg.createSVGPoint();
                pt.x = e.clientX;
                pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

                const newVb = {
                    x: vb.x + (svgP.x - vb.x) * (1 - scaleFactor),
                    y: vb.y + (svgP.y - vb.y) * (1 - scaleFactor),
                    w: vb.w * scaleFactor,
                    h: vb.h * scaleFactor
                };

                viewBoxRef.current = newVb;
                applyViewBox(newVb);

                // Debounced commit: sync to React after scrolling stops
                clearTimeout(wheelTimerId.current);
                wheelTimerId.current = setTimeout(commitViewBox, 150);
            };

            const handleMouseDown = (e) => {
                if (!activeRef.current || !viewBoxRef.current) return;
                isDragging.current = true;
                startPoint.current = { x: e.clientX, y: e.clientY, pendingX: e.clientX, pendingY: e.clientY };
            };

            // rAF-throttled drag: at most one DOM update per display frame
            const handleMouseMove = (e) => {
                if (!activeRef.current || !viewBoxRef.current || !isDragging.current) return;
                e.preventDefault();

                startPoint.current.pendingX = e.clientX;
                startPoint.current.pendingY = e.clientY;

                if (rafId.current) return; // frame already queued

                rafId.current = requestAnimationFrame(() => {
                    rafId.current = null;
                    const sp = startPoint.current;
                    const dx = sp.pendingX - sp.x;
                    const dy = sp.pendingY - sp.y;
                    sp.x = sp.pendingX;
                    sp.y = sp.pendingY;

                    const svg = svgElRef.current;
                    if (!svg) return;
                    const screenW = svg.getBoundingClientRect().width;
                    const vb = viewBoxRef.current;
                    const scale = vb.w / screenW;

                    const newVb = {
                        ...vb,
                        x: vb.x - dx * scale,
                        y: vb.y - dy * scale
                    };
                    viewBoxRef.current = newVb;
                    applyViewBox(newVb);
                });
            };

            const handleMouseUp = () => {
                isDragging.current = false;
                if (rafId.current) {
                    cancelAnimationFrame(rafId.current);
                    rafId.current = null;
                }
                commitViewBox(); // Sync to React state on drag end
            };

            // Stable event registration — re-registers when active tab changes
            // OR when the diagram loads (initialViewBox changes). This handles the
            // case where the tab becomes active before the SVG is loaded (e.g. N-1
            // "Generating..." placeholder): events re-attach when the SVG appears.
            useEffect(() => {
                const el = svgRef.current;
                if (!el || !active) return;

                // Re-apply saved viewBox to the DOM when becoming active again
                // (e.g. returning from the overflow tab). The container stays
                // mounted so the ref is valid, but the SVG viewBox attribute may
                // need refreshing after being hidden.
                if (viewBoxRef.current) {
                    applyViewBox(viewBoxRef.current);
                }

                el.addEventListener('wheel', handleWheel, { passive: false });
                el.addEventListener('mousedown', handleMouseDown);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);

                return () => {
                    el.removeEventListener('wheel', handleWheel);
                    el.removeEventListener('mousedown', handleMouseDown);
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                    clearTimeout(wheelTimerId.current);
                    if (rafId.current) cancelAnimationFrame(rafId.current);
                };
            }, [active, initialViewBox]);

            // Public API: updates ref + DOM + React state immediately
            const setViewBoxPublic = (vb) => {
                viewBoxRef.current = vb;
                applyViewBox(vb);
                setViewBox(vb);
            };

            return { viewBox, setViewBox: setViewBoxPublic };
        };

        // Scale SVG elements for large grids so text, nodes, and flow values
        // are readable when zoomed in and naturally shrink at full view.
        // Uses DOMParser for in-place DOM manipulation instead of regex on
        // multi-MB strings, avoiding large temporary string copies.
        const boostSvgForLargeGrid = (svgString, viewBox, vlCount) => {
            if (!viewBox) return svgString;

            // Skip boost entirely for grids with < 500 voltage levels —
            // smaller grids render well at native pypowsybl sizes.
            if (!vlCount || vlCount < 500) return svgString;

            const diagramSize = Math.max(viewBox.w, viewBox.h);
            const REFERENCE_SIZE = 1250; // small grid where everything is readable
            const BOOST_THRESHOLD = 3;   // ratio above which we start boosting
            const ratio = diagramSize / REFERENCE_SIZE;
            if (ratio <= BOOST_THRESHOLD) return svgString; // viewBox too small for boost

            // Normalized boost: starts at 1.0 at threshold, increases gradually.
            // ratio=4 → 1.15, ratio=6 → 1.41, ratio=9 → 1.73, ratio=12 → 2.0
            const boost = Math.sqrt(ratio / BOOST_THRESHOLD);
            console.log(`[SVG] vlCount=${vlCount}, viewBox ${diagramSize.toFixed(0)}, ratio ${ratio.toFixed(2)}, boost ${boost.toFixed(2)}`);

            const parser = new DOMParser();
            const doc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgEl = doc.documentElement;

            // Only enable text-hiding for genuinely large grids where text is
            // unreadable at full zoom-out (~4px on screen). Decoupled from
            // the boost threshold so medium-large grids keep text always visible.
            if (ratio > 6) {
                svgEl.setAttribute('data-large-grid', 'true');
            }

            // === 1. Scale CSS values in <style> blocks ===
            const styles = svgEl.querySelectorAll('style');
            styles.forEach(style => {
                let css = style.textContent;
                // Node label font
                css = css.replace(/font:\s*25px\s+serif/, `font: ${Math.round(25 * boost)}px serif`);
                // Label box padding and border-radius
                css = css.replace(
                    'padding: 10px; border-radius: 10px;',
                    `padding: ${Math.round(10 * boost)}px; border-radius: ${Math.round(10 * boost)}px;`
                );
                // Legend square sizes
                css = css.replace(
                    'margin-right: 10px; width: 20px; height: 20px;',
                    `margin-right: ${Math.round(10 * boost)}px; width: ${Math.round(20 * boost)}px; height: ${Math.round(20 * boost)}px;`
                );
                style.textContent = css;
            });

            // === 2. Scale node groups (circles + inner bus sectors/paths) ===
            // Scale the entire parent <g> so both the outer circle AND inner
            // path sectors (multi-bus VLs like PYMONP3) scale uniformly.
            const scaledGroups = new Set();
            svgEl.querySelectorAll('circle').forEach(circle => {
                const g = circle.parentElement;
                if (!g || g.tagName !== 'g' || scaledGroups.has(g)) return;
                // Skip groups containing labels — those scale via CSS
                if (g.querySelector('foreignObject')) return;
                scaledGroups.add(g);
                const cx = parseFloat(circle.getAttribute('cx')) || 0;
                const cy = parseFloat(circle.getAttribute('cy')) || 0;
                const t = g.getAttribute('transform') || '';
                g.setAttribute('transform',
                    `${t} translate(${cx},${cy}) scale(${boost.toFixed(2)}) translate(${-cx},${-cy})`);
            });

            // === 3. Scale edge-info group transforms (flow arrows + values) ===
            // DON'T scale the edge-info CSS font separately — the transform handles it.
            const edgeInfoGroup = svgEl.querySelector('.nad-edge-infos');
            if (edgeInfoGroup) {
                edgeInfoGroup.querySelectorAll(':scope > g[transform]').forEach(g => {
                    const t = g.getAttribute('transform');
                    if (t && t.includes('translate(') && !t.includes('scale(')) {
                        g.setAttribute('transform', t + ` scale(${boost.toFixed(2)})`);
                    }
                });
            }

            return new XMLSerializer().serializeToString(svgEl);
        };

        // Build Map indices from metadata for O(1) lookups in zoomToElement
        const buildMetadataIndex = (metadata) => {
            if (!metadata) return null;
            const meta = typeof metadata === 'string' ? JSON.parse(metadata) : metadata;
            const nodes = meta.nodes || [];
            const edges = meta.edges || [];

            const nodesByEquipmentId = new Map();
            const nodesBySvgId = new Map();
            const edgesByEquipmentId = new Map();
            const edgesByNode = new Map(); // svgId -> [edge, ...]

            nodes.forEach(n => {
                nodesByEquipmentId.set(n.equipmentId, n);
                nodesBySvgId.set(n.svgId, n);
            });

            edges.forEach(e => {
                edgesByEquipmentId.set(e.equipmentId, e);
                if (!edgesByNode.has(e.node1)) edgesByNode.set(e.node1, []);
                edgesByNode.get(e.node1).push(e);
                if (!edgesByNode.has(e.node2)) edgesByNode.set(e.node2, []);
                edgesByNode.get(e.node2).push(e);
            });

            return { nodesByEquipmentId, nodesBySvgId, edgesByEquipmentId, edgesByNode };
        };

        // Apply orange highlights to overloaded line edges on a given SVG container
        const applyOverloadedHighlights = (container, metaIndex, overloadedLines) => {
            if (!container || !metaIndex || !overloadedLines || overloadedLines.length === 0) return;

            // Clear previous overloaded highlights
            container.querySelectorAll('.nad-overloaded').forEach(el => el.classList.remove('nad-overloaded'));

            const { edgesByEquipmentId } = metaIndex;
            overloadedLines.forEach(lineName => {
                const edge = edgesByEquipmentId.get(lineName);
                if (edge && edge.svgId) {
                    const el = container.querySelector(`[id="${edge.svgId}"]`);
                    if (el) el.classList.add('nad-overloaded');
                }
            });
        };

        // Determine which lines an action acts upon (for line disconnection/reconnection actions).
        // Returns an array of line names, or empty array if the action is not line-only.
        const getActionTargetLines = (actionDetail) => {
            const topo = actionDetail?.action_topology;
            if (!topo) return [];

            const lineKeys = new Set([
                ...Object.keys(topo.lines_ex_bus || {}),
                ...Object.keys(topo.lines_or_bus || {}),
            ]);
            const genKeys = Object.keys(topo.gens_bus || {});
            const loadKeys = Object.keys(topo.loads_bus || {});

            // Single asset across all fields → line action
            if (lineKeys.size > 0 && genKeys.length === 0 && loadKeys.length === 0) {
                return [...lineKeys];
            }

            // Multiple assets but ALL values are -1 → multiple line disconnections
            const allValues = [
                ...Object.values(topo.lines_ex_bus || {}),
                ...Object.values(topo.lines_or_bus || {}),
                ...Object.values(topo.gens_bus || {}),
                ...Object.values(topo.loads_bus || {}),
            ];
            if (allValues.length > 0 && allValues.every(v => v === -1)) {
                return [...lineKeys];
            }

            return [];
        };

        // Apply yellow fluo highlights to lines the action acts upon
        const applyActionTargetHighlights = (container, metaIndex, lineNames) => {
            if (!container) return;
            container.querySelectorAll('.nad-action-target').forEach(el => el.classList.remove('nad-action-target'));
            if (!metaIndex || !lineNames || lineNames.length === 0) return;

            const { edgesByEquipmentId } = metaIndex;
            lineNames.forEach(lineName => {
                const edge = edgesByEquipmentId.get(lineName);
                if (edge && edge.svgId) {
                    const el = container.querySelector(`[id="${edge.svgId}"]`);
                    if (el) el.classList.add('nad-action-target');
                }
            });
        };

        function App() {
            const [networkPath, setNetworkPath] = useState(localStorage.getItem('networkPath') || '/home/marotant/dev/Expert_op4grid_recommender/data/bare_env_20240828T0100Z_dijon_only');
            const [actionPath, setActionPath] = useState(localStorage.getItem('actionPath') || '/home/marotant/dev/Expert_op4grid_recommender/data/action_space/reduced_model_actions_20240828T0100Z_new_dijon.json');
            const [branches, setBranches] = useState([]);
            const [voltageLevels, setVoltageLevels] = useState([]);
            const [selectedBranch, setSelectedBranch] = useState('');
            const [configLoading, setConfigLoading] = useState(false);
            const [analysisLoading, setAnalysisLoading] = useState(false);
            const [error, setError] = useState('');
            const [result, setResult] = useState(null);
            const [infoMessage, setInfoMessage] = useState('');
            const [inspectQuery, setInspectQuery] = useState('');

            // Visualization State
            const [activeTab, setActiveTab] = useState('n'); // 'n', 'n-1', 'overflow'
            const activeTabRef = useRef(activeTab);
            // useLayoutEffect to ensure ref is updated before any layout effects (like svg-pan-zoom) run
            useLayoutEffect(() => { activeTabRef.current = activeTab; }, [activeTab]);
            const prevTabRef = useRef(activeTab);

            const [nDiagram, setNDiagram] = useState(null);
            const [n1Diagram, setN1Diagram] = useState(null);
            const [n1Loading, setN1Loading] = useState(false);

            // Action variant diagram state
            const [selectedActionId, setSelectedActionId] = useState(null);
            const [actionDiagram, setActionDiagram] = useState(null);
            const [actionDiagramLoading, setActionDiagramLoading] = useState(false);

            const [originalViewBox, setOriginalViewBox] = useState(null);

            // Independent Refs for N, N-1, and Action Variant
            const nSvgContainerRef = useRef(null);
            const n1SvgContainerRef = useRef(null);
            const actionSvgContainerRef = useRef(null);

            // Native Pan/Zoom Instances
            const nPZ = usePanZoom(nSvgContainerRef, nDiagram?.originalViewBox, activeTab === 'n');
            const n1PZ = usePanZoom(n1SvgContainerRef, n1Diagram?.originalViewBox, activeTab === 'n-1');
            const actionPZ = usePanZoom(actionSvgContainerRef, actionDiagram?.originalViewBox, activeTab === 'action');

            // View State Management for Synchronization
            const lastViewStateN = useRef(null); // { zoom, pan: {x, y} }
            const lastViewStateN1 = useRef(null); // { zoom, pan: {x, y} }
            const lastZoomState = useRef({ query: '', branch: '' }); // Tracks last auto-zoom triggers
            // Captured viewBox to re-apply after the action diagram loads
            // (the tab-switch sync fires before the SVG exists, then
            // usePanZoom resets to the diagram's native viewBox).
            const actionSyncSourceRef = useRef(null);


            useEffect(() => { localStorage.setItem('networkPath', networkPath); }, [networkPath]);
            useEffect(() => { localStorage.setItem('actionPath', actionPath); }, [actionPath]);

            const pickPath = async (type, setter) => {
                try {
                    const res = await axios.get(`${API_BASE}/api/pick-path?type=${type}`);
                    if (res.data.path) setter(res.data.path);
                } catch (err) { setError('Failed to open file picker'); }
            };

            const handleLoadConfig = async () => {
                setConfigLoading(true); setError(''); setInfoMessage('');
                setNDiagram(null); setN1Diagram(null); setResult(null);
                setSelectedActionId(null); setActionDiagram(null);
                setActiveTab('n');
                lastViewStateN.current = null; // Reset view state on new config
                lastViewStateN1.current = null;
                lastZoomState.current = { query: '', branch: '' };

                try {
                    await axios.post(API_BASE + '/api/config', { network_path: networkPath, action_file_path: actionPath });

                    const [branchesRes, vlRes] = await Promise.all([
                        axios.get(API_BASE + '/api/branches'),
                        axios.get(API_BASE + '/api/voltage-levels')
                    ]);

                    setBranches(branchesRes.data.branches);
                    setVoltageLevels(vlRes.data.voltage_levels);

                    fetchBaseDiagram(vlRes.data.voltage_levels.length);
                } catch (err) {
                    setError('Failed to load config: ' + (err.response?.data?.detail || err.message));
                } finally { setConfigLoading(false); }
            };

            const processSvg = (rawSvg, vlCount) => {
                const match = rawSvg.match(/viewBox=["']([^"']+)["']/);
                let vb = null;
                if (match) {
                    const parts = match[1].split(/\s+|,/).map(parseFloat);
                    if (parts.length === 4) vb = { x: parts[0], y: parts[1], w: parts[2], h: parts[3] };
                }

                // Diagnostic: log SVG root attributes and embedded CSS for debugging
                const svgTag = rawSvg.match(/<svg[^>]*>/)?.[0] || '';
                const widthMatch = svgTag.match(/\bwidth=["']([^"']+)["']/);
                const heightMatch = svgTag.match(/\bheight=["']([^"']+)["']/);
                console.log(`[SVG processSvg] vlCount=${vlCount}, viewBox=${vb ? `${vb.w.toFixed(0)}x${vb.h.toFixed(0)}` : 'none'}, svgWidth=${widthMatch?.[1] || 'none'}, svgHeight=${heightMatch?.[1] || 'none'}`);

                // Boost text/label sizes for large grids before injection
                const svg = boostSvgForLargeGrid(rawSvg, vb, vlCount);
                return { svg, viewBox: vb };
            };

            const handleManualReset = () => {
                setInspectQuery('');

                const currentPZ = activeTab === 'action' ? actionPZ : activeTab === 'n' ? nPZ : n1PZ;
                const currentDiagram = activeTab === 'action' ? actionDiagram : activeTab === 'n' ? nDiagram : n1Diagram;
                const viewBox = currentDiagram?.originalViewBox || originalViewBox;

                if (currentPZ && viewBox) {
                    currentPZ.setViewBox(viewBox);
                    lastZoomState.current = { query: '', branch: '' };
                }

                // Clear highlights
                const container = activeTab === 'action' ? actionSvgContainerRef.current
                    : activeTab === 'n' ? nSvgContainerRef.current : n1SvgContainerRef.current;
                if (container) {
                    container.querySelectorAll('.nad-highlight').forEach(el => el.classList.remove('nad-highlight'));
                }
            };

            const fetchBaseDiagram = async (vlCount) => {
                try {
                    const res = await axios.get(API_BASE + '/api/network-diagram');
                    const { svg, viewBox } = processSvg(res.data.svg, vlCount || 0);
                    if (viewBox) setOriginalViewBox(viewBox);
                    setNDiagram({ ...res.data, svg, originalViewBox: viewBox });
                } catch (err) { console.error('Failed to fetch diagram:', err); }
            };

            // Fetch N-1 Diagram when contingency is selected (ONLY if valid branch)
            useEffect(() => {
                if (!selectedBranch) {
                    setN1Diagram(null);
                    return;
                }

                // Prevent fetching if the branch is not in the valid list (e.g. user is still typing)
                if (branches.length > 0 && !branches.includes(selectedBranch)) {
                    return;
                }

                const fetchN1 = async () => {
                    setN1Loading(true);
                    setActiveTab('n-1'); // Switch immediately → shows "Generating N-1 Diagram..."
                    try {
                        const res = await axios.post(API_BASE + '/api/n1-diagram', { disconnected_element: selectedBranch });
                        const { svg, viewBox } = processSvg(res.data.svg, voltageLevels.length);
                        setN1Diagram({ ...res.data, svg, originalViewBox: viewBox }); // Embed viewBox
                    } catch (err) {
                        console.error("Failed to fetch N-1 diagram", err);
                        setError(`Failed to fetch N-1 diagram for ${selectedBranch}`);
                    } finally {
                        setN1Loading(false);
                    }
                };
                fetchN1();
            }, [selectedBranch, branches]);

            // Auto-switch to overflow tab when analysis runs
            const handleRunAnalysis = async () => {
                if (!selectedBranch) return;
                setAnalysisLoading(true); setError(''); setResult(null); setInfoMessage('');
                setSelectedActionId(null); setActionDiagram(null);
                setActiveTab('overflow');

                try {
                    const response = await fetch(API_BASE + '/api/run-analysis', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ disconnected_element: selectedBranch })
                    });
                    if (!response.ok) throw new Error('Analysis failed');
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep incomplete line in buffer
                        for (const line of lines) {
                            if (!line.trim()) continue;
                            try {
                                const event = JSON.parse(line);
                                if (event.type === 'pdf') setResult(p => ({ ...p, pdf_url: event.pdf_url }));
                                else if (event.type === 'result') { setResult(event); if (event.message) setInfoMessage(event.message); }
                                else if (event.type === 'error') setError('Analysis failed: ' + event.message);
                            } catch (e) {
                                console.error('Stream error:', e);
                            }
                        }
                    }
                } catch (err) { setError('Analysis failed: ' + err.message); }
                finally { setAnalysisLoading(false); }
            };

            // Fetch action variant diagram when an action card is clicked
            const handleActionSelect = async (actionId) => {
                if (actionId === selectedActionId) {
                    // Deselect — return to previous diagram tab
                    setSelectedActionId(null);
                    setActionDiagram(null);
                    setActiveTab('n-1');
                    return;
                }

                // Capture current viewBox so we can re-apply it after the
                // action diagram loads (the tab-switch sync fires before
                // the SVG exists, then usePanZoom resets to the native
                // viewBox — we need to override that).
                actionSyncSourceRef.current =
                    (activeTabRef.current === 'action' ? actionPZ.viewBox : null)
                    || n1PZ.viewBox || nPZ.viewBox;

                setSelectedActionId(actionId);
                setActionDiagram(null);
                setActionDiagramLoading(true);
                setActiveTab('action');
                try {
                    const res = await axios.post(API_BASE + '/api/action-variant-diagram', { action_id: actionId });
                    const { svg, viewBox } = processSvg(res.data.svg, voltageLevels.length);
                    setActionDiagram({ ...res.data, svg, originalViewBox: viewBox });
                } catch (err) {
                    console.error('Failed to fetch action variant diagram:', err);
                    setError('Failed to fetch action variant diagram for ' + actionId);
                } finally {
                    setActionDiagramLoading(false);
                }
            };





            // --- Synchronization Logic ---
            // When switching directly between N, N-1, and Action tabs, sync
            // the zoom/pan state so all diagram tabs show the same region.
            // When returning from the overflow tab, each tab keeps its own
            // saved zoom state.
            useEffect(() => {
                const prevTab = prevTabRef.current;
                prevTabRef.current = activeTab;

                // Don't sync when coming from / going to overflow
                if (prevTab === 'overflow' || activeTab === 'overflow') return;

                // Find the source viewBox from the previous tab
                const sourceVB = prevTab === 'n' ? nPZ.viewBox
                    : prevTab === 'n-1' ? n1PZ.viewBox
                    : prevTab === 'action' ? actionPZ.viewBox
                    : null;
                if (!sourceVB) return;

                // Apply to the new active tab
                if (activeTab === 'n' && nPZ.setViewBox) {
                    nPZ.setViewBox(sourceVB);
                } else if (activeTab === 'n-1' && n1PZ.setViewBox) {
                    n1PZ.setViewBox(sourceVB);
                } else if (activeTab === 'action' && actionPZ.setViewBox) {
                    actionPZ.setViewBox(sourceVB);
                }
            }, [activeTab]);

            // Re-sync after action diagram loads: usePanZoom's initialViewBox
            // effect resets to the diagram's native viewBox, so we override it
            // with the captured source viewBox from the tab the user was on.
            useEffect(() => {
                if (actionDiagram && activeTab === 'action' && actionSyncSourceRef.current) {
                    actionPZ.setViewBox(actionSyncSourceRef.current);
                    actionSyncSourceRef.current = null;
                }
            }, [actionDiagram]);

            // Pre-indexed metadata for O(1) lookups in zoomToElement
            const nMetaIndex = useMemo(() => buildMetadataIndex(nDiagram?.metadata), [nDiagram?.metadata]);
            const n1MetaIndex = useMemo(() => buildMetadataIndex(n1Diagram?.metadata), [n1Diagram?.metadata]);
            const actionMetaIndex = useMemo(() => buildMetadataIndex(actionDiagram?.metadata), [actionDiagram?.metadata]);

            // Highlight overloaded lines in orange on N-1 and Action diagrams,
            // and highlight acted-upon lines in yellow fluo on Action diagram.
            useEffect(() => {
                const overloadedLines = result?.lines_overloaded || [];

                // N-1: highlight all initially overloaded lines
                if (n1SvgContainerRef.current && n1MetaIndex && overloadedLines.length > 0) {
                    applyOverloadedHighlights(n1SvgContainerRef.current, n1MetaIndex, overloadedLines);
                }

                // Action diagram highlights
                if (actionSvgContainerRef.current && actionMetaIndex && selectedActionId && result?.actions) {
                    const actionDetail = result.actions[selectedActionId];
                    if (actionDetail) {
                        // Orange: lines that remain >100% after the action
                        const stillOverloaded = [];
                        if (overloadedLines.length > 0 && actionDetail.rho_after) {
                            overloadedLines.forEach((name, i) => {
                                if (actionDetail.rho_after[i] != null && actionDetail.rho_after[i] > 1.0) {
                                    stillOverloaded.push(name);
                                }
                            });
                        }
                        if (actionDetail.max_rho != null && actionDetail.max_rho > 1.0 && actionDetail.max_rho_line) {
                            if (!stillOverloaded.includes(actionDetail.max_rho_line)) {
                                stillOverloaded.push(actionDetail.max_rho_line);
                            }
                        }
                        applyOverloadedHighlights(actionSvgContainerRef.current, actionMetaIndex, stillOverloaded);

                        // Yellow fluo: lines the action acts upon (line disconnection/reconnection only)
                        const targetLines = getActionTargetLines(actionDetail);
                        applyActionTargetHighlights(actionSvgContainerRef.current, actionMetaIndex, targetLines);
                    }
                } else {
                    // Clear action target highlights when no action is selected
                    if (actionSvgContainerRef.current) {
                        applyActionTargetHighlights(actionSvgContainerRef.current, null, []);
                    }
                }
            }, [n1Diagram, actionDiagram, n1MetaIndex, actionMetaIndex, result, selectedActionId]);

            // Zoom to an element by computing its bounding box from metadata
            const zoomToElement = (targetId) => {
                const currentPZ = activeTab === 'action' ? actionPZ : activeTab === 'n' ? nPZ : n1PZ;
                const container = activeTab === 'action' ? actionSvgContainerRef.current : activeTab === 'n' ? nSvgContainerRef.current : n1SvgContainerRef.current;
                const index = activeTab === 'action' ? actionMetaIndex : activeTab === 'n' ? nMetaIndex : n1MetaIndex;
                if (!currentPZ || !container || !index) return;

                try {
                    const { nodesByEquipmentId, nodesBySvgId, edgesByEquipmentId, edgesByNode } = index;
                    const points = [];

                    const addNodePointsBySvgId = (svgId) => {
                        const n = nodesBySvgId.get(svgId);
                        if (n) points.push({ x: n.x, y: n.y });
                        return n;
                    };

                    const targetNode = nodesByEquipmentId.get(targetId);
                    const targetEdge = edgesByEquipmentId.get(targetId);
                    let targetSvgId;

                    if (targetNode) {
                        targetSvgId = targetNode.svgId;
                        points.push({ x: targetNode.x, y: targetNode.y });
                        (edgesByNode.get(targetNode.svgId) || []).forEach(e => {
                            addNodePointsBySvgId(e.node1);
                            addNodePointsBySvgId(e.node2);
                        });
                    } else if (targetEdge) {
                        targetSvgId = targetEdge.svgId;
                        const n1 = addNodePointsBySvgId(targetEdge.node1);
                        const n2 = addNodePointsBySvgId(targetEdge.node2);
                        if (n1) (edgesByNode.get(n1.svgId) || []).forEach(e => { addNodePointsBySvgId(e.node1); addNodePointsBySvgId(e.node2); });
                        if (n2) (edgesByNode.get(n2.svgId) || []).forEach(e => { addNodePointsBySvgId(e.node1); addNodePointsBySvgId(e.node2); });
                    }

                    if (points.length > 0) {
                        const minX = Math.min(...points.map(p => p.x));
                        const maxX = Math.max(...points.map(p => p.x));
                        const minY = Math.min(...points.map(p => p.y));
                        const maxY = Math.max(...points.map(p => p.y));

                        const centerX = (minX + maxX) / 2;
                        const centerY = (minY + maxY) / 2;
                        const boxW = Math.max(maxX - minX, 50);
                        const boxH = Math.max(maxY - minY, 50);

                        const padding = 1.8;
                        const screenW = container.getBoundingClientRect().width;
                        const screenH = container.getBoundingClientRect().height;
                        const screenAR = screenW / screenH;

                        let targetW = boxW * padding;
                        let targetH = boxH * padding;

                        if (targetW / targetH > screenAR) {
                            targetH = targetW / screenAR;
                        } else {
                            targetW = targetH * screenAR;
                        }

                        const targetX = centerX - targetW / 2;
                        const targetY = centerY - targetH / 2;

                        currentPZ.setViewBox({ x: targetX, y: targetY, w: targetW, h: targetH });

                        // Highlight the target element
                        container.querySelectorAll('.nad-highlight').forEach(el => el.classList.remove('nad-highlight'));
                        if (targetSvgId) {
                            const el = container.querySelector(`[id="${targetSvgId}"]`);
                            if (el) el.classList.add('nad-highlight');
                        }
                    }
                } catch (e) { console.error('Zoom failed:', e); }
            };

            // Auto-zoom to selected element via viewBox
            useEffect(() => {
                if (activeTab === 'overflow') return;

                const queryChanged = inspectQuery !== lastZoomState.current.query;
                const branchChanged = !inspectQuery && selectedBranch !== lastZoomState.current.branch;

                if (!queryChanged && !branchChanged) return;

                let targetId = inspectQuery || selectedBranch;

                // Cleared inspect → reset view
                if (!targetId && queryChanged) {
                    lastZoomState.current = { query: inspectQuery, branch: selectedBranch };
                    handleManualReset();
                    return;
                }

                if (!targetId) return;

                // Branch changes should zoom on the N-1 tab, not N.
                // In the same render cycle, setActiveTab('n-1') is batched but
                // not committed — this effect still sees activeTab='n'. Skip here;
                // the effect re-runs when activeTab changes to 'n-1'.
                if (branchChanged && activeTab === 'n') return;

                // Only consume the zoom intent when the container has SVG content.
                // If not ready (e.g. N-1 still loading), skip — the effect re-runs
                // when n1Diagram changes, and branchChanged will still be true.
                const container = activeTab === 'action' ? actionSvgContainerRef.current
                    : activeTab === 'n' ? nSvgContainerRef.current : n1SvgContainerRef.current;
                if (!container || !container.querySelector('svg')) return;

                lastZoomState.current = { query: inspectQuery, branch: selectedBranch };
                zoomToElement(targetId);

            }, [activeTab, nDiagram, n1Diagram, actionDiagram, inspectQuery, selectedBranch]);



            const inspectableItems = [...branches, ...voltageLevels].sort();

            const renderVisualization = () => {
                return (
                    <div style={{ width: '100%', height: '100%', position: 'relative' }}>
                        {/* Overflow Container */}
                        {activeTab === 'overflow' && (
                            <div style={{
                                width: '100%', height: '100%',
                                position: 'absolute', top: 0, left: 0,
                                backgroundColor: 'white', zIndex: 20
                            }}>
                                {result?.pdf_url || result?.plot_json ? (
                                    result.pdf_url ?
                                        <iframe src={API_BASE + result.pdf_url} key={result.pdf_url} style={{ width: '100%', height: '100%', border: 'none' }} />
                                        : <iframe srcDoc={result.plot_html} style={{ width: '100%', height: '100%', border: 'none' }} />
                                ) : (
                                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>
                                        {analysisLoading ? 'Processing Analysis...' : 'Run analysis to see overflow graph'}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* N Container — always mounted, hidden via CSS to preserve zoom state */}
                        <div style={{
                            width: '100%', height: '100%',
                            position: 'absolute', top: 0, left: 0,
                            zIndex: activeTab === 'n' ? 10 : -1,
                            visibility: activeTab === 'n' ? 'visible' : 'hidden',
                            pointerEvents: activeTab === 'n' ? 'auto' : 'none'
                        }}>
                            {nDiagram?.svg ?
                                <div className="svg-container" ref={nSvgContainerRef} dangerouslySetInnerHTML={{ __html: nDiagram.svg }} />
                                : <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Load configuration to see diagram</div>
                            }
                        </div>

                        {/* N-1 Container — always mounted, hidden via CSS to preserve zoom state */}
                        <div style={{
                            width: '100%', height: '100%',
                            position: 'absolute', top: 0, left: 0,
                            zIndex: activeTab === 'n-1' ? 10 : -1,
                            visibility: activeTab === 'n-1' ? 'visible' : 'hidden',
                            pointerEvents: activeTab === 'n-1' ? 'auto' : 'none'
                        }}>
                            {/* Convergence warning banner */}
                            {n1Diagram && n1Diagram.lf_converged === false && (
                                <div style={{
                                    position: 'absolute', top: 0, left: 0, right: 0, zIndex: 30,
                                    background: '#fff3cd', color: '#856404', padding: '6px 12px',
                                    fontSize: '0.8rem', borderBottom: '1px solid #ffc107',
                                    textAlign: 'center', pointerEvents: 'none'
                                }}>
                                    ⚠ AC load flow: {n1Diagram.lf_status || 'did not converge'} — voltage values may be missing or approximate
                                </div>
                            )}
                            {n1Loading ?
                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Generating N-1 Diagram...</div>
                                : (n1Diagram?.svg ?
                                    <div className="svg-container" ref={n1SvgContainerRef} dangerouslySetInnerHTML={{ __html: n1Diagram.svg }} />
                                    : <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Select a target contingency to view N-1</div>
                                )
                            }
                        </div>

                        {/* Action Variant Container — always mounted, hidden via CSS to preserve zoom state */}
                        <div style={{
                            width: '100%', height: '100%',
                            position: 'absolute', top: 0, left: 0,
                            zIndex: activeTab === 'action' ? 10 : -1,
                            visibility: activeTab === 'action' ? 'visible' : 'hidden',
                            pointerEvents: activeTab === 'action' ? 'auto' : 'none'
                        }}>
                            {/* Convergence warning banner */}
                            {actionDiagram && actionDiagram.lf_converged === false && (
                                <div style={{
                                    position: 'absolute', top: 0, left: 0, right: 0, zIndex: 30,
                                    background: '#fff3cd', color: '#856404', padding: '6px 12px',
                                    fontSize: '0.8rem', borderBottom: '1px solid #ffc107',
                                    textAlign: 'center', pointerEvents: 'none'
                                }}>
                                    ⚠ AC load flow: {actionDiagram.lf_status || 'did not converge'} — voltage values may be missing or approximate
                                </div>
                            )}
                            {actionDiagramLoading ?
                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Generating Action Variant Diagram...</div>
                                : (actionDiagram?.svg ?
                                    <div className="svg-container" ref={actionSvgContainerRef} dangerouslySetInnerHTML={{ __html: actionDiagram.svg }} />
                                    : (selectedActionId ?
                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Failed to load diagram for action {selectedActionId}</div>
                                        : <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Select an action card to view its network variant</div>
                                    )
                                )
                            }
                        </div>
                    </div>
                );
            };



            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
                    <header>
                        <h2 style={{ margin: 0 }}>⚡ Expert Recommender</h2>
                        <div style={{ fontSize: '0.8rem', opacity: 0.7 }}>Standalone Interface v3.0 (Multi-Tab)</div>
                    </header>
                    <div className="config-panel">
                        <div style={{ flex: '1 1 250px', display: 'flex', flexDirection: 'column', gap: '5px' }}>
                            <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Network Path</label>
                            <div style={{ display: 'flex', gap: '5px' }}>
                                <input type="text" value={networkPath} onChange={e => setNetworkPath(e.target.value)} style={{ flex: 1 }} />
                                <button onClick={() => pickPath('dir', setNetworkPath)} style={{ padding: '8px', background: '#7f8c8d' }}>📂</button>
                            </div>
                        </div>
                        <div style={{ flex: '1 1 250px', display: 'flex', flexDirection: 'column', gap: '5px' }}>
                            <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Action File Path</label>
                            <div style={{ display: 'flex', gap: '5px' }}>
                                <input type="text" value={actionPath} onChange={e => setActionPath(e.target.value)} style={{ flex: 1 }} />
                                <button onClick={() => pickPath('file', setActionPath)} style={{ padding: '8px', background: '#7f8c8d' }}>📄</button>
                            </div>
                        </div>
                        <button onClick={handleLoadConfig} disabled={configLoading}>
                            {configLoading ? '⏳ Loading...' : '🔄 Load Config'}
                        </button>
                        {branches.length > 0 && (
                            <div style={{ flex: '1 1 300px', display: 'flex', gap: '15px', alignItems: 'end' }}>
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '5px' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Target Contingency</label>
                                    <input list="contingencies" value={selectedBranch} onChange={e => setSelectedBranch(e.target.value)} placeholder="Search line/bus..." style={{ padding: '8px' }} />
                                    <datalist id="contingencies">{branches.map(b => <option key={b} value={b} />)}</datalist>
                                </div>
                                <button onClick={handleRunAnalysis} disabled={!selectedBranch || analysisLoading} style={{ background: '#27ae60' }}>
                                    {analysisLoading ? '⚙️ Running...' : '🚀 Run Analysis'}
                                </button>
                            </div>
                        )}
                        {branches.length > 0 && (
                            <div style={{ flex: '1 1 200px', display: 'flex', flexDirection: 'column', gap: '5px' }}>
                                <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Inspect Line/Bus/VL</label>
                                <div style={{ display: 'flex', gap: '5px' }}>
                                    <input
                                        list="inspectables"
                                        value={inspectQuery}
                                        onChange={e => setInspectQuery(e.target.value)}
                                        placeholder="Zoom to..."
                                        style={{ flex: 1, padding: '8px', border: inspectQuery ? '2px solid #3498db' : '1px solid #ccc' }}
                                    />
                                    <datalist id="inspectables">{inspectableItems.map(b => <option key={b} value={b} />)}</datalist>
                                    {inspectQuery && (
                                        <button onClick={() => setInspectQuery('')} style={{ background: '#e74c3c', padding: '0 10px' }} title="Clear">
                                            ✖
                                        </button>
                                    )}
                                </div>
                            </div>
                        )}
                        <button onClick={handleManualReset} style={{ background: '#bdc3c7', color: '#333' }}>
                            Reset View
                        </button>
                    </div>
                    <div className="main-content">
                        <div className="action-feed">
                            <h3>Actions</h3>
                            {result?.lines_overloaded && result.lines_overloaded.length > 0 && (
                                <div style={{ marginBottom: '10px', padding: '6px 10px', background: '#fff3cd', border: '1px solid #ffc107', borderRadius: '6px', fontSize: '13px' }}>
                                    <strong>Overloaded lines:</strong> {result.lines_overloaded.join(', ')}
                                </div>
                            )}
                            {result?.actions && Object.keys(result.actions).length > 0 ? (
                                Object.entries(result.actions).sort(([, a], [, b]) => (a.max_rho ?? 999) - (b.max_rho ?? 999)).map(([id, details], index) => {
                                    const maxRhoPct = details.max_rho != null ? (details.max_rho * 100).toFixed(1) : null;
                                    const overloadedLines = result.lines_overloaded || [];
                                    // Tri-color severity: red (>100%), orange (>90%), green (<=90%)
                                    const severity = details.max_rho != null
                                        ? (details.max_rho > 1.0 ? 'red' : details.max_rho > 0.9 ? 'orange' : 'green')
                                        : (details.is_rho_reduction ? 'green' : 'red');
                                    const severityColors = {
                                        green:  { border: '#28a745', badgeBg: '#d4edda', badgeText: '#155724', label: 'Solves overload' },
                                        orange: { border: '#f0ad4e', badgeBg: '#fff3cd', badgeText: '#856404', label: 'Solved — low margin' },
                                        red:    { border: '#dc3545', badgeBg: '#f8d7da', badgeText: '#721c24', label: details.is_rho_reduction ? 'Still overloaded' : 'No reduction' }
                                    };
                                    const sc = severityColors[severity];
                                    const formatRho = (arr) => {
                                        if (!arr || arr.length === 0) return '—';
                                        return arr.map((v, i) => `${overloadedLines[i] || 'line ' + i}: ${(v * 100).toFixed(1)}%`).join(', ');
                                    };
                                    const isSelected = selectedActionId === id;
                                    return (
                                    <div key={id} className="card" onClick={() => handleActionSelect(id)} style={{
                                        borderLeftColor: isSelected ? '#007bff' : sc.border,
                                        cursor: 'pointer',
                                        background: isSelected ? '#e7f1ff' : 'white',
                                        boxShadow: isSelected ? '0 0 0 2px rgba(0,123,255,0.3), 0 2px 8px rgba(0,0,0,0.15)' : '0 2px 4px rgba(0,0,0,0.1)',
                                        transition: 'all 0.15s ease'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                            <h4 style={{ margin: 0, color: isSelected ? '#0056b3' : undefined }}>#{index + 1} — {id}</h4>
                                            <div style={{ display: 'flex', gap: '5px', alignItems: 'center' }}>
                                                {isSelected && (
                                                    <span style={{ fontSize: '10px', fontWeight: 600, padding: '2px 6px', borderRadius: '4px', background: '#007bff', color: 'white' }}>
                                                        VIEWING
                                                    </span>
                                                )}
                                                <span style={{ fontSize: '11px', fontWeight: 600, padding: '2px 8px', borderRadius: '12px', background: sc.badgeBg, color: sc.badgeText }}>
                                                    {sc.label}
                                                </span>
                                            </div>
                                        </div>
                                        <p style={{ fontSize: '13px' }}>{details.description_unitaire}</p>
                                        <div style={{ fontSize: '12px', background: isSelected ? '#dce8f7' : '#f8f9fa', padding: '5px', marginTop: '5px' }}>
                                            <div>Rho before: {formatRho(details.rho_before)}</div>
                                            <div>Rho after: {formatRho(details.rho_after)}</div>
                                            {maxRhoPct != null && (
                                                <div style={{ marginTop: '3px' }}>
                                                    Max rho: <strong style={{ color: sc.border }}>{maxRhoPct}%</strong>
                                                    {details.max_rho_line && <span style={{ color: '#888' }}> on {details.max_rho_line}</span>}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    );
                                })
                            ) : <p style={{ color: '#666', fontStyle: 'italic' }}>{analysisLoading ? 'Processing...' : 'No actions available.'}</p>}
                        </div>
                        <div className="visualization" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div style={{ display: 'flex', borderBottom: '1px solid #ccc' }}>
                                <button
                                    onClick={() => setActiveTab('n')}
                                    style={{ flex: 1, borderRadius: 0, background: activeTab === 'n' ? 'white' : '#ecf0f1', color: activeTab === 'n' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'n' ? '3px solid #3498db' : 'none' }}
                                >
                                    Network (N)
                                </button>
                                <button
                                    onClick={() => setActiveTab('n-1')}
                                    style={{ flex: 1, borderRadius: 0, background: activeTab === 'n-1' ? 'white' : '#ecf0f1', color: activeTab === 'n-1' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'n-1' ? '3px solid #e74c3c' : 'none' }}
                                >
                                    Contingency (N-1)
                                </button>
                                {selectedActionId && (
                                    <button
                                        onClick={() => setActiveTab('action')}
                                        style={{ flex: 1, borderRadius: 0, background: activeTab === 'action' ? 'white' : '#ecf0f1', color: activeTab === 'action' ? '#0056b3' : '#7f8c8d', borderBottom: activeTab === 'action' ? '3px solid #007bff' : 'none' }}
                                    >
                                        Action: {selectedActionId}
                                    </button>
                                )}
                                {result && (
                                    <button
                                        onClick={() => setActiveTab('overflow')}
                                        style={{ flex: 1, borderRadius: 0, background: activeTab === 'overflow' ? 'white' : '#ecf0f1', color: activeTab === 'overflow' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'overflow' ? '3px solid #27ae60' : 'none' }}
                                    >
                                        Overflow Analysis
                                    </button>
                                )}
                            </div>
                            <div style={{ flex: 1, position: 'relative', overflow: 'hidden' }}>
                                {renderVisualization()}
                            </div>
                        </div>
                    </div>
                    {error && <div style={{ position: 'fixed', bottom: 20, right: 20, background: '#e74c3c', color: 'white', padding: '10px 20px', borderRadius: '4px', boxShadow: '0 2px 10px rgba(0,0,0,0.2)' }}>❌ {error}</div>}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>