<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expert_op4grid Standalone Interface</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <!-- svg-pan-zoom removed -->
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .config-panel {
            background: #f4f4f4;
            padding: 15px;
            border-bottom: 1px solid #ccc;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: end;
        }

        .config-panel input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .action-feed {
            width: 25%;
            background: #eee;
            border-right: 1px solid #ccc;
            padding: 15px;
            overflow-y: auto;
        }

        .visualization {
            flex: 1;
            background: white;
            position: relative;
        }

        .card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #dc3545;
        }

        .card h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }

        button {
            padding: 8px 15px;
            cursor: pointer;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }


        .svg-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .svg-container svg {
            width: 100%;
            height: 100%;
        }

        /* Keep lines/paths visible at any zoom level without breaking fills/colors */
        .svg-container svg path,
        .svg-container svg line,
        .svg-container svg polyline {
            vector-effect: non-scaling-stroke;
        }

        .error {
            color: red;
            margin-top: 5px;
            font-size: 12px;
        }

        /* Highlight styles: persistent and simple */
        .nad-highlight {
            stroke: #e74c3c !important;
            stroke-width: 4px !important;
            opacity: 0.9;
        }

        circle.nad-highlight {
            fill: #e74c3c !important;
        }

        /* Hide text on large grids at full zoom ‚Äî revealed by removing this class.
           display:none removes elements from layout entirely, so the browser
           skips layout/paint for thousands of text nodes at initial load. */
        .svg-container.text-hidden foreignObject,
        .svg-container.text-hidden .nad-edge-infos,
        .svg-container.text-hidden .nad-text-edges {
            display: none !important;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useLayoutEffect, useMemo, Fragment, useRef } = React;
        const API_BASE = 'http://localhost:8000';

        // Custom Hook for SVG Pan/Zoom logic
        // Performance: viewBox updates go directly to the DOM via refs,
        // bypassing React's render cycle during active interaction.
        // React state is only synced on interaction end / pause.
        const usePanZoom = (svgRef, initialViewBox, active) => {
            // React state: "settled" viewBox for downstream consumers
            const [viewBox, setViewBox] = useState(null);
            // Mutable ref for the hot path ‚Äî updated every frame, no React render
            const viewBoxRef = useRef(null);
            const isDragging = useRef(false);
            const startPoint = useRef({ x: 0, y: 0 });
            const wheelTimerId = useRef(null);
            const rafId = useRef(null);
            // Cached SVG element ref ‚Äî avoids querySelector on every event
            const svgElRef = useRef(null);
            const activeRef = useRef(active);
            activeRef.current = active;
            // Original viewBox max dimension ‚Äî used for relative text visibility threshold
            const initialMaxDimRef = useRef(null);

            // Direct DOM update ‚Äî no React involved
            const applyViewBox = (vb) => {
                const svg = svgElRef.current;
                if (svg && vb) {
                    svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
                }
                // Toggle text visibility based on zoom level (large grids only).
                // Show text when zoomed in to < 50% of original viewBox (2x+ zoom).
                // This scales with grid size: zoomToElement typically zooms to
                // 10-30% of the grid, so text always appears on element focus.
                const container = svgRef.current;
                if (container && vb && svg && svg.hasAttribute('data-large-grid')) {
                    const origMax = initialMaxDimRef.current;
                    const shouldHide = !origMax || Math.max(vb.w, vb.h) / origMax >= 0.5;
                    container.classList.toggle('text-hidden', shouldHide);
                }
            };

            // Flush ref -> React state for downstream consumers
            const commitViewBox = () => {
                if (viewBoxRef.current) {
                    setViewBox({ ...viewBoxRef.current });
                }
            };

            // Cache SVG element when container content changes.
            // Also hide text immediately on large grids to prevent a flash
            // of unreadable text before the first applyViewBox call.
            useLayoutEffect(() => {
                if (svgRef.current) {
                    svgElRef.current = svgRef.current.querySelector('svg');
                    if (svgElRef.current && svgElRef.current.hasAttribute('data-large-grid')) {
                        const vb = viewBoxRef.current;
                        const origMax = initialMaxDimRef.current;
                        if (!vb || !origMax || Math.max(vb.w, vb.h) / origMax >= 0.5) {
                            svgRef.current.classList.add('text-hidden');
                        }
                    }
                } else {
                    svgElRef.current = null;
                }
            });

            // Sync from initialViewBox (diagram load or programmatic reset)
            useEffect(() => {
                if (initialViewBox) {
                    viewBoxRef.current = initialViewBox;
                    initialMaxDimRef.current = Math.max(initialViewBox.w, initialViewBox.h);
                    applyViewBox(initialViewBox);
                    setViewBox(initialViewBox);
                }
            }, [initialViewBox]);

            const handleWheel = (e) => {
                if (!activeRef.current || !viewBoxRef.current) return;
                e.preventDefault();
                const vb = viewBoxRef.current;
                const scaleFactor = e.deltaY > 0 ? 1.1 : 0.9;

                const svg = svgElRef.current;
                if (!svg) return;

                const pt = svg.createSVGPoint();
                pt.x = e.clientX;
                pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

                const newVb = {
                    x: vb.x + (svgP.x - vb.x) * (1 - scaleFactor),
                    y: vb.y + (svgP.y - vb.y) * (1 - scaleFactor),
                    w: vb.w * scaleFactor,
                    h: vb.h * scaleFactor
                };

                viewBoxRef.current = newVb;
                applyViewBox(newVb);

                // Debounced commit: sync to React after scrolling stops
                clearTimeout(wheelTimerId.current);
                wheelTimerId.current = setTimeout(commitViewBox, 150);
            };

            const handleMouseDown = (e) => {
                if (!activeRef.current || !viewBoxRef.current) return;
                isDragging.current = true;
                startPoint.current = { x: e.clientX, y: e.clientY, pendingX: e.clientX, pendingY: e.clientY };
            };

            // rAF-throttled drag: at most one DOM update per display frame
            const handleMouseMove = (e) => {
                if (!activeRef.current || !viewBoxRef.current || !isDragging.current) return;
                e.preventDefault();

                startPoint.current.pendingX = e.clientX;
                startPoint.current.pendingY = e.clientY;

                if (rafId.current) return; // frame already queued

                rafId.current = requestAnimationFrame(() => {
                    rafId.current = null;
                    const sp = startPoint.current;
                    const dx = sp.pendingX - sp.x;
                    const dy = sp.pendingY - sp.y;
                    sp.x = sp.pendingX;
                    sp.y = sp.pendingY;

                    const svg = svgElRef.current;
                    if (!svg) return;
                    const screenW = svg.getBoundingClientRect().width;
                    const vb = viewBoxRef.current;
                    const scale = vb.w / screenW;

                    const newVb = {
                        ...vb,
                        x: vb.x - dx * scale,
                        y: vb.y - dy * scale
                    };
                    viewBoxRef.current = newVb;
                    applyViewBox(newVb);
                });
            };

            const handleMouseUp = () => {
                isDragging.current = false;
                if (rafId.current) {
                    cancelAnimationFrame(rafId.current);
                    rafId.current = null;
                }
                commitViewBox(); // Sync to React state on drag end
            };

            // Stable event registration ‚Äî only depends on active tab, not viewBox
            useEffect(() => {
                const el = svgRef.current;
                if (!el || !active) return;

                el.addEventListener('wheel', handleWheel, { passive: false });
                el.addEventListener('mousedown', handleMouseDown);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);

                return () => {
                    el.removeEventListener('wheel', handleWheel);
                    el.removeEventListener('mousedown', handleMouseDown);
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                    clearTimeout(wheelTimerId.current);
                    if (rafId.current) cancelAnimationFrame(rafId.current);
                };
            }, [active]);

            // Public API: updates ref + DOM + React state immediately
            const setViewBoxPublic = (vb) => {
                viewBoxRef.current = vb;
                applyViewBox(vb);
                setViewBox(vb);
            };

            return { viewBox, setViewBox: setViewBoxPublic };
        };

        // Scale SVG elements for large grids so text, nodes, and flow values
        // are readable when zoomed in and naturally shrink at full view.
        // Uses DOMParser for in-place DOM manipulation instead of regex on
        // multi-MB strings, avoiding large temporary string copies.
        const boostSvgForLargeGrid = (svgString, viewBox) => {
            if (!viewBox) return svgString;

            const diagramSize = Math.max(viewBox.w, viewBox.h);
            const REFERENCE_SIZE = 1250; // small grid where everything is readable
            const ratio = diagramSize / REFERENCE_SIZE;
            if (ratio <= 1.5) return svgString; // small grid, no boost needed

            const boost = Math.sqrt(ratio);

            const parser = new DOMParser();
            const doc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgEl = doc.documentElement;

            // Mark as large grid so usePanZoom can toggle text visibility on zoom
            svgEl.setAttribute('data-large-grid', 'true');

            // === 1. Scale CSS values in <style> blocks ===
            const styles = svgEl.querySelectorAll('style');
            styles.forEach(style => {
                let css = style.textContent;
                // Node label font
                css = css.replace(/font:\s*25px\s+serif/, `font: ${Math.round(25 * boost)}px serif`);
                // Label box padding and border-radius
                css = css.replace(
                    'padding: 10px; border-radius: 10px;',
                    `padding: ${Math.round(10 * boost)}px; border-radius: ${Math.round(10 * boost)}px;`
                );
                // Legend square sizes
                css = css.replace(
                    'margin-right: 10px; width: 20px; height: 20px;',
                    `margin-right: ${Math.round(10 * boost)}px; width: ${Math.round(20 * boost)}px; height: ${Math.round(20 * boost)}px;`
                );
                style.textContent = css;
            });

            // === 2. Scale circle radii (bus nodes + windings) ===
            svgEl.querySelectorAll('circle').forEach(circle => {
                const r = parseFloat(circle.getAttribute('r'));
                if (!isNaN(r)) {
                    circle.setAttribute('r', (r * boost).toFixed(2));
                }
            });

            // === 3. Scale edge-info group transforms (flow arrows + values) ===
            // DON'T scale the edge-info CSS font separately ‚Äî the transform handles it.
            const edgeInfoGroup = svgEl.querySelector('.nad-edge-infos');
            if (edgeInfoGroup) {
                edgeInfoGroup.querySelectorAll(':scope > g[transform]').forEach(g => {
                    const t = g.getAttribute('transform');
                    if (t && t.includes('translate(') && !t.includes('scale(')) {
                        g.setAttribute('transform', t + ` scale(${boost.toFixed(2)})`);
                    }
                });
            }

            return new XMLSerializer().serializeToString(svgEl);
        };

        // Build Map indices from metadata for O(1) lookups in zoomToElement
        const buildMetadataIndex = (metadata) => {
            if (!metadata) return null;
            const meta = typeof metadata === 'string' ? JSON.parse(metadata) : metadata;
            const nodes = meta.nodes || [];
            const edges = meta.edges || [];

            const nodesByEquipmentId = new Map();
            const nodesBySvgId = new Map();
            const edgesByEquipmentId = new Map();
            const edgesByNode = new Map(); // svgId -> [edge, ...]

            nodes.forEach(n => {
                nodesByEquipmentId.set(n.equipmentId, n);
                nodesBySvgId.set(n.svgId, n);
            });

            edges.forEach(e => {
                edgesByEquipmentId.set(e.equipmentId, e);
                if (!edgesByNode.has(e.node1)) edgesByNode.set(e.node1, []);
                edgesByNode.get(e.node1).push(e);
                if (!edgesByNode.has(e.node2)) edgesByNode.set(e.node2, []);
                edgesByNode.get(e.node2).push(e);
            });

            return { nodesByEquipmentId, nodesBySvgId, edgesByEquipmentId, edgesByNode };
        };

        function App() {
            const [networkPath, setNetworkPath] = useState(localStorage.getItem('networkPath') || '/home/marotant/dev/Expert_op4grid_recommender/data/bare_env_20240828T0100Z_dijon_only');
            const [actionPath, setActionPath] = useState(localStorage.getItem('actionPath') || '/home/marotant/dev/Expert_op4grid_recommender/data/action_space/reduced_model_actions_20240828T0100Z_new_dijon.json');
            const [branches, setBranches] = useState([]);
            const [voltageLevels, setVoltageLevels] = useState([]);
            const [selectedBranch, setSelectedBranch] = useState('');
            const [configLoading, setConfigLoading] = useState(false);
            const [analysisLoading, setAnalysisLoading] = useState(false);
            const [error, setError] = useState('');
            const [result, setResult] = useState(null);
            const [infoMessage, setInfoMessage] = useState('');
            const [inspectQuery, setInspectQuery] = useState('');

            // Visualization State
            const [activeTab, setActiveTab] = useState('n'); // 'n', 'n-1', 'overflow'
            const activeTabRef = useRef(activeTab);
            // useLayoutEffect to ensure ref is updated before any layout effects (like svg-pan-zoom) run
            useLayoutEffect(() => { activeTabRef.current = activeTab; }, [activeTab]);
            const [reinitCount, setReinitCount] = useState(0);
            const prevTabRef = useRef(activeTab);

            // Force re-init when returning from overflow tab to fix visibility issues
            useEffect(() => {
                if (prevTabRef.current === 'overflow' && activeTab !== 'overflow') {
                    setReinitCount(c => c + 1);
                }
                prevTabRef.current = activeTab;
            }, [activeTab]);

            const [nDiagram, setNDiagram] = useState(null);
            const [n1Diagram, setN1Diagram] = useState(null);
            const [n1Loading, setN1Loading] = useState(false);

            const [originalViewBox, setOriginalViewBox] = useState(null);

            // Independent Refs for N and N-1
            const nSvgContainerRef = useRef(null);
            const n1SvgContainerRef = useRef(null);

            // Native Pan/Zoom Instances
            const nPZ = usePanZoom(nSvgContainerRef, nDiagram?.originalViewBox, activeTab === 'n');
            const n1PZ = usePanZoom(n1SvgContainerRef, n1Diagram?.originalViewBox, activeTab === 'n-1');

            // View State Management for Synchronization
            const lastViewStateN = useRef(null); // { zoom, pan: {x, y} }
            const lastViewStateN1 = useRef(null); // { zoom, pan: {x, y} }
            const lastZoomState = useRef({ query: '', branch: '' }); // Tracks last auto-zoom triggers


            useEffect(() => { localStorage.setItem('networkPath', networkPath); }, [networkPath]);
            useEffect(() => { localStorage.setItem('actionPath', actionPath); }, [actionPath]);

            const pickPath = async (type, setter) => {
                try {
                    const res = await axios.get(`${API_BASE}/api/pick-path?type=${type}`);
                    if (res.data.path) setter(res.data.path);
                } catch (err) { setError('Failed to open file picker'); }
            };

            const handleLoadConfig = async () => {
                setConfigLoading(true); setError(''); setInfoMessage('');
                setNDiagram(null); setN1Diagram(null); setResult(null);
                setActiveTab('n');
                lastViewStateN.current = null; // Reset view state on new config
                lastViewStateN1.current = null;
                lastZoomState.current = { query: '', branch: '' };

                try {
                    await axios.post(API_BASE + '/api/config', { network_path: networkPath, action_file_path: actionPath });

                    const [branchesRes, vlRes] = await Promise.all([
                        axios.get(API_BASE + '/api/branches'),
                        axios.get(API_BASE + '/api/voltage-levels')
                    ]);

                    setBranches(branchesRes.data.branches);
                    setVoltageLevels(vlRes.data.voltage_levels);

                    fetchBaseDiagram();
                } catch (err) {
                    setError('Failed to load config: ' + (err.response?.data?.detail || err.message));
                } finally { setConfigLoading(false); }
            };

            const processSvg = (rawSvg) => {
                const match = rawSvg.match(/viewBox=["']([^"']+)["']/);
                let vb = null;
                if (match) {
                    const parts = match[1].split(/\s+|,/).map(parseFloat);
                    if (parts.length === 4) vb = { x: parts[0], y: parts[1], w: parts[2], h: parts[3] };
                }
                // Boost text/label sizes for large grids before injection
                const svg = boostSvgForLargeGrid(rawSvg, vb);
                return { svg, viewBox: vb };
            };

            const handleManualReset = () => {
                setInspectQuery('');

                const currentPZ = activeTab === 'n' ? nPZ : n1PZ;
                const currentDiagram = activeTab === 'n' ? nDiagram : n1Diagram;
                const viewBox = currentDiagram?.originalViewBox || originalViewBox;

                if (currentPZ && viewBox) {
                    currentPZ.setViewBox(viewBox);
                    lastZoomState.current = { query: '', branch: '' };
                }

                // Clear highlights
                const container = activeTab === 'n' ? nSvgContainerRef.current : n1SvgContainerRef.current;
                if (container) {
                    container.querySelectorAll('.nad-highlight').forEach(el => el.classList.remove('nad-highlight'));
                }
            };

            const fetchBaseDiagram = async () => {
                try {
                    const res = await axios.get(API_BASE + '/api/network-diagram');
                    const { svg, viewBox } = processSvg(res.data.svg);
                    if (viewBox) setOriginalViewBox(viewBox);
                    setNDiagram({ ...res.data, svg, originalViewBox: viewBox });
                } catch (err) { console.error('Failed to fetch diagram:', err); }
            };

            // Fetch N-1 Diagram when contingency is selected (ONLY if valid branch)
            useEffect(() => {
                if (!selectedBranch) {
                    setN1Diagram(null);
                    return;
                }

                // Prevent fetching if the branch is not in the valid list (e.g. user is still typing)
                if (branches.length > 0 && !branches.includes(selectedBranch)) {
                    return;
                }

                const fetchN1 = async () => {
                    setN1Loading(true);
                    try {
                        const res = await axios.post(API_BASE + '/api/n1-diagram', { disconnected_element: selectedBranch });
                        const { svg, viewBox } = processSvg(res.data.svg);
                        setN1Diagram({ ...res.data, svg, originalViewBox: viewBox }); // Embed viewBox
                        setActiveTab('n-1');
                    } catch (err) {
                        console.error("Failed to fetch N-1 diagram", err);
                        setError(`Failed to fetch N-1 diagram for ${selectedBranch}`);
                    } finally {
                        setN1Loading(false);
                    }
                };
                fetchN1();
            }, [selectedBranch, branches]);

            // Auto-switch to overflow tab when analysis runs
            const handleRunAnalysis = async () => {
                if (!selectedBranch) return;
                setAnalysisLoading(true); setError(''); setResult(null); setInfoMessage('');
                setActiveTab('overflow');

                try {
                    const response = await fetch(API_BASE + '/api/run-analysis', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ disconnected_element: selectedBranch })
                    });
                    if (!response.ok) throw new Error('Analysis failed');
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep incomplete line in buffer
                        for (const line of lines) {
                            if (!line.trim()) continue;
                            try {
                                const event = JSON.parse(line);
                                if (event.type === 'pdf') setResult(p => ({ ...p, pdf_url: event.pdf_url }));
                                else if (event.type === 'result') { setResult(event); if (event.message) setInfoMessage(event.message); }
                                else if (event.type === 'error') setError('Analysis failed: ' + event.message);
                            } catch (e) {
                                console.error('Stream error:', e);
                            }
                        }
                    }
                } catch (err) { setError('Analysis failed: ' + err.message); }
                finally { setAnalysisLoading(false); }
            };








            // --- Synchronization Logic ---
            // When switching tabs, apply current view state to the new tab
            useEffect(() => {
                if (activeTab === 'n') {
                    // Sync N from N-1
                    if (n1PZ.viewBox && nPZ.setViewBox) {
                        nPZ.setViewBox(n1PZ.viewBox);
                    }
                } else if (activeTab === 'n-1') {
                    // Sync N-1 from N
                    if (nPZ.viewBox && n1PZ.setViewBox) {
                        n1PZ.setViewBox(nPZ.viewBox);
                    }
                }
            }, [activeTab]);

            // Pre-indexed metadata for O(1) lookups in zoomToElement
            const nMetaIndex = useMemo(() => buildMetadataIndex(nDiagram?.metadata), [nDiagram?.metadata]);
            const n1MetaIndex = useMemo(() => buildMetadataIndex(n1Diagram?.metadata), [n1Diagram?.metadata]);

            // Zoom to an element by computing its bounding box from metadata
            const zoomToElement = (targetId) => {
                const currentPZ = activeTab === 'n' ? nPZ : n1PZ;
                const container = activeTab === 'n' ? nSvgContainerRef.current : n1SvgContainerRef.current;
                const index = activeTab === 'n' ? nMetaIndex : n1MetaIndex;
                if (!currentPZ || !container || !index) return;

                try {
                    const { nodesByEquipmentId, nodesBySvgId, edgesByEquipmentId, edgesByNode } = index;
                    const points = [];

                    const addNodePointsBySvgId = (svgId) => {
                        const n = nodesBySvgId.get(svgId);
                        if (n) points.push({ x: n.x, y: n.y });
                        return n;
                    };

                    const targetNode = nodesByEquipmentId.get(targetId);
                    const targetEdge = edgesByEquipmentId.get(targetId);
                    let targetSvgId;

                    if (targetNode) {
                        targetSvgId = targetNode.svgId;
                        points.push({ x: targetNode.x, y: targetNode.y });
                        (edgesByNode.get(targetNode.svgId) || []).forEach(e => {
                            addNodePointsBySvgId(e.node1);
                            addNodePointsBySvgId(e.node2);
                        });
                    } else if (targetEdge) {
                        targetSvgId = targetEdge.svgId;
                        const n1 = addNodePointsBySvgId(targetEdge.node1);
                        const n2 = addNodePointsBySvgId(targetEdge.node2);
                        if (n1) (edgesByNode.get(n1.svgId) || []).forEach(e => { addNodePointsBySvgId(e.node1); addNodePointsBySvgId(e.node2); });
                        if (n2) (edgesByNode.get(n2.svgId) || []).forEach(e => { addNodePointsBySvgId(e.node1); addNodePointsBySvgId(e.node2); });
                    }

                    if (points.length > 0) {
                        const minX = Math.min(...points.map(p => p.x));
                        const maxX = Math.max(...points.map(p => p.x));
                        const minY = Math.min(...points.map(p => p.y));
                        const maxY = Math.max(...points.map(p => p.y));

                        const centerX = (minX + maxX) / 2;
                        const centerY = (minY + maxY) / 2;
                        const boxW = Math.max(maxX - minX, 50);
                        const boxH = Math.max(maxY - minY, 50);

                        const padding = 1.8;
                        const screenW = container.getBoundingClientRect().width;
                        const screenH = container.getBoundingClientRect().height;
                        const screenAR = screenW / screenH;

                        let targetW = boxW * padding;
                        let targetH = boxH * padding;

                        if (targetW / targetH > screenAR) {
                            targetH = targetW / screenAR;
                        } else {
                            targetW = targetH * screenAR;
                        }

                        const targetX = centerX - targetW / 2;
                        const targetY = centerY - targetH / 2;

                        currentPZ.setViewBox({ x: targetX, y: targetY, w: targetW, h: targetH });

                        // Highlight the target element
                        container.querySelectorAll('.nad-highlight').forEach(el => el.classList.remove('nad-highlight'));
                        if (targetSvgId) {
                            const el = container.querySelector(`[id="${targetSvgId}"]`);
                            if (el) el.classList.add('nad-highlight');
                        }
                    }
                } catch (e) { console.error('Zoom failed:', e); }
            };

            // Auto-zoom to selected element via viewBox
            useEffect(() => {
                if (activeTab === 'overflow') return;

                const queryChanged = inspectQuery !== lastZoomState.current.query;
                const branchChanged = !inspectQuery && selectedBranch !== lastZoomState.current.branch;

                if (!queryChanged && !branchChanged) return;

                lastZoomState.current = { query: inspectQuery, branch: selectedBranch };

                let targetId = inspectQuery || selectedBranch;

                // Cleared inspect ‚Üí reset view
                if (!targetId && queryChanged) {
                    handleManualReset();
                    return;
                }

                if (!targetId) return;

                zoomToElement(targetId);

            }, [activeTab, nDiagram, n1Diagram, inspectQuery, selectedBranch]);




            const inspectableItems = [...branches, ...voltageLevels].sort();

            const renderVisualization = () => {
                return (
                    <div style={{ width: '100%', height: '100%', position: 'relative' }}>
                        {/* Overflow Container */}
                        {activeTab === 'overflow' && (
                            <div style={{
                                width: '100%', height: '100%',
                                position: 'absolute', top: 0, left: 0,
                                backgroundColor: 'white', zIndex: 20
                            }}>
                                {result?.pdf_url || result?.plot_json ? (
                                    result.pdf_url ?
                                        <iframe src={API_BASE + result.pdf_url} key={result.pdf_url} style={{ width: '100%', height: '100%', border: 'none' }} />
                                        : <iframe srcDoc={result.plot_html} style={{ width: '100%', height: '100%', border: 'none' }} />
                                ) : (
                                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>
                                        {analysisLoading ? 'Processing Analysis...' : 'Run analysis to see overflow graph'}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* N Container ‚Äî only mounted when active to halve DOM weight */}
                        {activeTab === 'n' && (
                            <div style={{
                                width: '100%', height: '100%',
                                position: 'absolute', top: 0, left: 0,
                                zIndex: 10
                            }}>
                                {nDiagram?.svg ?
                                    <div className="svg-container" ref={nSvgContainerRef} dangerouslySetInnerHTML={{ __html: nDiagram.svg }} />
                                    : <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Load configuration to see diagram</div>
                                }
                            </div>
                        )}

                        {/* N-1 Container ‚Äî only mounted when active to halve DOM weight */}
                        {activeTab === 'n-1' && (
                            <div style={{
                                width: '100%', height: '100%',
                                position: 'absolute', top: 0, left: 0,
                                zIndex: 10
                            }}>
                                {n1Loading ?
                                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Generating N-1 Diagram...</div>
                                    : (n1Diagram?.svg ?
                                        <div className="svg-container" ref={n1SvgContainerRef} dangerouslySetInnerHTML={{ __html: n1Diagram.svg }} />
                                        : <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Select a target contingency to view N-1</div>
                                    )
                                }
                            </div>
                        )}
                    </div>
                );
            };



            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
                    <header>
                        <h2 style={{ margin: 0 }}>‚ö° Expert Recommender</h2>
                        <div style={{ fontSize: '0.8rem', opacity: 0.7 }}>Standalone Interface v3.0 (Multi-Tab)</div>
                    </header>
                    <div className="config-panel">
                        <div style={{ flex: '1 1 250px', display: 'flex', flexDirection: 'column', gap: '5px' }}>
                            <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Network Path</label>
                            <div style={{ display: 'flex', gap: '5px' }}>
                                <input type="text" value={networkPath} onChange={e => setNetworkPath(e.target.value)} style={{ flex: 1 }} />
                                <button onClick={() => pickPath('dir', setNetworkPath)} style={{ padding: '8px', background: '#7f8c8d' }}>üìÇ</button>
                            </div>
                        </div>
                        <div style={{ flex: '1 1 250px', display: 'flex', flexDirection: 'column', gap: '5px' }}>
                            <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Action File Path</label>
                            <div style={{ display: 'flex', gap: '5px' }}>
                                <input type="text" value={actionPath} onChange={e => setActionPath(e.target.value)} style={{ flex: 1 }} />
                                <button onClick={() => pickPath('file', setActionPath)} style={{ padding: '8px', background: '#7f8c8d' }}>üìÑ</button>
                            </div>
                        </div>
                        <button onClick={handleLoadConfig} disabled={configLoading}>
                            {configLoading ? '‚è≥ Loading...' : 'üîÑ Load Config'}
                        </button>
                        {branches.length > 0 && (
                            <div style={{ flex: '1 1 300px', display: 'flex', gap: '15px', alignItems: 'end' }}>
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '5px' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Target Contingency</label>
                                    <input list="contingencies" value={selectedBranch} onChange={e => setSelectedBranch(e.target.value)} placeholder="Search line/bus..." style={{ padding: '8px' }} />
                                    <datalist id="contingencies">{branches.map(b => <option key={b} value={b} />)}</datalist>
                                </div>
                                <button onClick={handleRunAnalysis} disabled={!selectedBranch || analysisLoading} style={{ background: '#27ae60' }}>
                                    {analysisLoading ? '‚öôÔ∏è Running...' : 'üöÄ Run Analysis'}
                                </button>
                            </div>
                        )}
                        {branches.length > 0 && (
                            <div style={{ flex: '1 1 200px', display: 'flex', flexDirection: 'column', gap: '5px' }}>
                                <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Inspect Line/Bus/VL</label>
                                <div style={{ display: 'flex', gap: '5px' }}>
                                    <input
                                        list="inspectables"
                                        value={inspectQuery}
                                        onChange={e => setInspectQuery(e.target.value)}
                                        placeholder="Zoom to..."
                                        style={{ flex: 1, padding: '8px', border: inspectQuery ? '2px solid #3498db' : '1px solid #ccc' }}
                                    />
                                    <datalist id="inspectables">{inspectableItems.map(b => <option key={b} value={b} />)}</datalist>
                                    {inspectQuery && (
                                        <button onClick={() => setInspectQuery('')} style={{ background: '#e74c3c', padding: '0 10px' }} title="Clear">
                                            ‚úñ
                                        </button>
                                    )}
                                </div>
                            </div>
                        )}
                        <button onClick={handleManualReset} style={{ background: '#bdc3c7', color: '#333' }}>
                            Reset View
                        </button>
                    </div>
                    <div className="main-content">
                        <div className="action-feed">
                            <h3>Actions</h3>
                            {result?.actions && Object.keys(result.actions).length > 0 ? (
                                Object.entries(result.actions).sort(([, a], [, b]) => (parseFloat(a.new_max_rho) || 999) - (parseFloat(b.new_max_rho) || 999)).map(([id, details]) => (
                                    <div key={id} className={`card ${details.new_max_rho === null ? 'ineffective' : ''}`} style={{ borderLeftColor: details.new_max_rho === null ? '#dc3545' : ((parseFloat(details.new_max_rho) || 999) < 0.9 ? '#28a745' : '#ffc107') }}>
                                        <h4>{id}</h4>
                                        <p style={{ fontSize: '13px' }}>{details.description_unitaire || details.description}</p>
                                        {details.new_max_rho !== null ? (
                                            <div style={{ fontSize: '12px', background: '#f8f9fa', padding: '5px', marginTop: '5px' }}>
                                                New Max Rho: <strong>{(parseFloat(details.new_max_rho)).toFixed(2)}</strong> {details.max_rho_line && `on ${details.max_rho_line}`}<br />
                                                {details.old_rho && details.new_rho && (
                                                    <div style={{ marginTop: '3px', color: '#555' }}>
                                                        Evolution: {details.old_rho} ‚Üí {details.new_rho}
                                                        {details.max_rho_line && <span> (on {details.max_rho_line})</span>}
                                                    </div>
                                                )}
                                            </div>
                                        ) : <div style={{ color: '#dc3545', fontSize: '11px' }}>‚ö†Ô∏è Ineffective</div>}
                                    </div>
                                ))
                            ) : <p style={{ color: '#666', fontStyle: 'italic' }}>{analysisLoading ? 'Processing...' : 'No actions available.'}</p>}
                        </div>
                        <div className="visualization" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div style={{ display: 'flex', borderBottom: '1px solid #ccc' }}>
                                <button
                                    onClick={() => setActiveTab('n')}
                                    style={{ flex: 1, borderRadius: 0, background: activeTab === 'n' ? 'white' : '#ecf0f1', color: activeTab === 'n' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'n' ? '3px solid #3498db' : 'none' }}
                                >
                                    Network (N)
                                </button>
                                <button
                                    onClick={() => setActiveTab('n-1')}
                                    style={{ flex: 1, borderRadius: 0, background: activeTab === 'n-1' ? 'white' : '#ecf0f1', color: activeTab === 'n-1' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'n-1' ? '3px solid #e74c3c' : 'none' }}
                                >
                                    Contingency (N-1)
                                </button>
                                {result && (
                                    <button
                                        onClick={() => setActiveTab('overflow')}
                                        style={{ flex: 1, borderRadius: 0, background: activeTab === 'overflow' ? 'white' : '#ecf0f1', color: activeTab === 'overflow' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'overflow' ? '3px solid #27ae60' : 'none' }}
                                    >
                                        Overflow Analysis
                                    </button>
                                )}
                            </div>
                            <div style={{ flex: 1, position: 'relative', overflow: 'hidden' }}>
                                {renderVisualization()}
                            </div>
                        </div>
                    </div>
                    {error && <div style={{ position: 'fixed', bottom: 20, right: 20, background: '#e74c3c', color: 'white', padding: '10px 20px', borderRadius: '4px', boxShadow: '0 2px 10px rgba(0,0,0,0.2)' }}>‚ùå {error}</div>}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>