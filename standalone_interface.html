<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expert_op4grid Standalone Interface</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <!-- svg-pan-zoom removed -->
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        header input[type="text"] {
            padding: 5px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.8rem;
            min-width: 0;
        }

        header input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        header label {
            font-size: 0.7rem;
            opacity: 0.8;
            white-space: nowrap;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .action-feed {
            width: 25%;
            background: #eee;
            border-right: 1px solid #ccc;
            padding: 15px;
            overflow-y: auto;
        }

        .visualization {
            flex: 1;
            background: white;
            position: relative;
        }

        .card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #dc3545;
        }

        .card h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }

        button {
            padding: 8px 15px;
            cursor: pointer;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }


        .svg-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .svg-container svg {
            width: 100%;
            height: 100%;
        }

        /* Keep lines/paths visible at any zoom level without breaking fills/colors */
        .svg-container svg path,
        .svg-container svg line,
        .svg-container svg polyline,
        .svg-container svg rect {
            vector-effect: non-scaling-stroke;
        }

        .error {
            color: red;
            margin-top: 5px;
            font-size: 12px;
        }

        /* Highlight styles: persistent and simple */
        .nad-highlight {
            stroke: #e74c3c !important;
            stroke-width: 4px !important;
            opacity: 0.9;
        }

        circle.nad-highlight {
            fill: #e74c3c !important;
        }

        /* Highlight overloaded lines in orange */
        .nad-overloaded path,
        .nad-overloaded line,
        .nad-overloaded polyline {
            stroke: #ff8c00 !important;
            stroke-width: 3px !important;
        }

        /* Apply drop-shadow to the parent clone group to create a glowing halo effect */
        .nad-action-target {
            filter: drop-shadow(0 0 8px #fffb00) drop-shadow(0 0 15px #fffb00) !important;
        }

        /* For lines and paths, use grid units for stroke-width so the halo is always significantly wider than the actual element it highlights. Using non-scaling-stroke makes it stay a fixed pixel width on screen, which can be narrower than the line when heavily zoomed in. */
        .nad-action-target path,
        .nad-action-target line,
        .nad-action-target polyline,
        .nad-action-target rect,
        .nad-action-target polygon {
            stroke: #fffb00 !important;
            stroke-width: 150px !important;
            stroke-opacity: 0.8 !important;
            fill: none !important;
            stroke-linecap: round !important;
            stroke-linejoin: round !important;
        }

        /* For nodes (circles and rects), add a screen-space stroke to create a glowing background halo that doesn't shrink into invisibility on large grids, avoiding obscuring the original node in the foreground. */
        .nad-action-target circle,
        .nad-action-target rect {
            stroke: #ffe600 !important;
            stroke-width: 45px !important;
            stroke-opacity: 0.6 !important;
            fill: #ffe600 !important;
            fill-opacity: 0.8 !important;
            vector-effect: non-scaling-stroke !important;
        }

        /* Hide text and foreignObjects in the background clone to avoid messy overlays */
        .nad-action-target text,
        .nad-action-target foreignObject {
            display: none !important;
        }

        /* Hide text on large grids at full zoom — revealed by removing this class.
           display:none removes elements from layout entirely, so the browser
           skips layout/paint for thousands of text nodes at initial load. */
        .svg-container.text-hidden foreignObject,
        .svg-container.text-hidden .nad-edge-infos,
        .svg-container.text-hidden .nad-text-edges {
            display: none !important;
        }

        /* ===== Delta flow visualization ===== */

        /* Positive delta: flow increased after action (orange) */
        .nad-delta-positive path,
        .nad-delta-positive line,
        .nad-delta-positive polyline {
            stroke: #ff8c00 !important;
            stroke-width: 3px !important;
        }

        /* Negative delta: flow decreased after action (blue) */
        .nad-delta-negative path,
        .nad-delta-negative line,
        .nad-delta-negative polyline {
            stroke: #2196F3 !important;
            stroke-width: 3px !important;
        }

        /* Grey: negligible change (below threshold) */
        .nad-delta-grey path,
        .nad-delta-grey line,
        .nad-delta-grey polyline {
            stroke: #999 !important;
            stroke-opacity: 0.4 !important;
        }

        /* ===== Voltage Range Slider (vertical, right sidebar) ===== */
        .voltage-sidebar {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 62px;
            background: rgba(244, 244, 244, 0.92);
            border-left: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 15;
            padding: 8px 0;
            box-sizing: border-box;
        }

        .voltage-sidebar .vs-label {
            font-size: 0.65rem;
            font-weight: bold;
            color: #2c3e50;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .voltage-sidebar .vs-range-label {
            font-size: 0.6rem;
            font-weight: bold;
            color: #2c3e50;
            background: #e8f0fe;
            border-radius: 3px;
            padding: 2px 4px;
            margin-bottom: 6px;
            text-align: center;
            line-height: 1.2;
        }

        .voltage-slider-container {
            position: relative;
            flex: 1;
            width: 28px;
            min-height: 0;
        }

        .voltage-slider-track {
            position: absolute;
            left: 12px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #ddd;
            border-radius: 2px;
        }

        .voltage-slider-range {
            position: absolute;
            left: 12px;
            width: 4px;
            background: #3498db;
            border-radius: 2px;
        }

        .voltage-slider-container input[type=range] {
            position: absolute;
            left: 0;
            width: 28px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            pointer-events: none;
            margin: 0;
            /* Rotate to vertical: slider runs bottom-to-top */
            writing-mode: vertical-lr;
            direction: rtl;
        }

        .voltage-slider-container input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #3498db;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            pointer-events: all;
        }

        .voltage-slider-container input[type=range]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #3498db;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            pointer-events: all;
        }

        .voltage-slider-ticks {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 28px;
            width: 24px;
        }

        .voltage-slider-ticks span {
            position: absolute;
            font-size: 0.58rem;
            color: #666;
            white-space: nowrap;
            transform: translateY(-50%);
            left: 2px;
        }

        /* VL focused diagram overlay body — SVG scales to fit width */
        .vl-overlay-body svg {
            width: 100%;
            height: auto;
            display: block;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useLayoutEffect, useMemo, Fragment, useRef } = React;
        const API_BASE = 'http://localhost:8000';

        // Custom Hook for SVG Pan/Zoom logic
        // Performance: viewBox updates go directly to the DOM via refs,
        // bypassing React's render cycle during active interaction.
        // React state is only synced on interaction end / pause.
        const usePanZoom = (svgRef, initialViewBox, active) => {
            // React state: "settled" viewBox for downstream consumers
            const [viewBox, setViewBox] = useState(null);
            // Mutable ref for the hot path — updated every frame, no React render
            const viewBoxRef = useRef(null);
            const isDragging = useRef(false);
            const startPoint = useRef({ x: 0, y: 0 });
            const wheelTimerId = useRef(null);
            const rafId = useRef(null);
            // Cached SVG element ref — avoids querySelector on every event
            const svgElRef = useRef(null);
            const activeRef = useRef(active);
            activeRef.current = active;
            // Original viewBox max dimension — used for relative text visibility threshold
            const initialMaxDimRef = useRef(null);

            // Direct DOM update — no React involved
            const applyViewBox = (vb) => {
                const svg = svgElRef.current;
                if (svg && vb) {
                    svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
                }
                // Toggle text visibility based on zoom level (large grids only).
                // Show text when zoomed in to < 50% of original viewBox (2x+ zoom).
                // This scales with grid size: zoomToElement typically zooms to
                // 10-30% of the grid, so text always appears on element focus.
                const container = svgRef.current;
                if (container && vb && svg && svg.hasAttribute('data-large-grid')) {
                    const origMax = initialMaxDimRef.current;
                    const shouldHide = !origMax || Math.max(vb.w, vb.h) / origMax >= 0.5;
                    container.classList.toggle('text-hidden', shouldHide);
                }
            };

            // Flush ref -> React state for downstream consumers
            const commitViewBox = () => {
                if (viewBoxRef.current) {
                    setViewBox({ ...viewBoxRef.current });
                }
            };

            // Cache SVG element when container content changes.
            // Also hide text immediately on large grids to prevent a flash
            // of unreadable text before the first applyViewBox call.
            useLayoutEffect(() => {
                if (svgRef.current) {
                    svgElRef.current = svgRef.current.querySelector('svg');
                    if (svgElRef.current && svgElRef.current.hasAttribute('data-large-grid')) {
                        const vb = viewBoxRef.current;
                        const origMax = initialMaxDimRef.current;
                        if (!vb || !origMax || Math.max(vb.w, vb.h) / origMax >= 0.5) {
                            svgRef.current.classList.add('text-hidden');
                        }
                    }
                } else {
                    svgElRef.current = null;
                }
            });

            // Sync from initialViewBox (diagram load or programmatic reset)
            useEffect(() => {
                if (initialViewBox) {
                    viewBoxRef.current = initialViewBox;
                    initialMaxDimRef.current = Math.max(initialViewBox.w, initialViewBox.h);
                    applyViewBox(initialViewBox);
                    setViewBox(initialViewBox);
                    // Diagnostic: log effective scaling
                    const el = svgRef.current;
                    if (el) {
                        const rect = el.getBoundingClientRect();
                        const scaleX = rect.width / initialViewBox.w;
                        const scaleY = rect.height / initialViewBox.h;
                        console.log(`[SVG render] container=${rect.width.toFixed(0)}x${rect.height.toFixed(0)}, viewBox=${initialViewBox.w.toFixed(0)}x${initialViewBox.h.toFixed(0)}, scale=${Math.min(scaleX, scaleY).toFixed(3)}`);
                    }
                }
            }, [initialViewBox]);

            const handleWheel = (e) => {
                if (!activeRef.current || !viewBoxRef.current) return;
                e.preventDefault();
                const vb = viewBoxRef.current;
                const scaleFactor = e.deltaY > 0 ? 1.1 : 0.9;

                const svg = svgElRef.current;
                if (!svg) return;

                const pt = svg.createSVGPoint();
                pt.x = e.clientX;
                pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

                const newVb = {
                    x: vb.x + (svgP.x - vb.x) * (1 - scaleFactor),
                    y: vb.y + (svgP.y - vb.y) * (1 - scaleFactor),
                    w: vb.w * scaleFactor,
                    h: vb.h * scaleFactor
                };

                viewBoxRef.current = newVb;
                applyViewBox(newVb);

                // Debounced commit: sync to React after scrolling stops
                clearTimeout(wheelTimerId.current);
                wheelTimerId.current = setTimeout(commitViewBox, 150);
            };

            const handleMouseDown = (e) => {
                if (!activeRef.current || !viewBoxRef.current) return;
                isDragging.current = true;
                startPoint.current = { x: e.clientX, y: e.clientY, pendingX: e.clientX, pendingY: e.clientY };
            };

            // rAF-throttled drag: at most one DOM update per display frame
            const handleMouseMove = (e) => {
                if (!activeRef.current || !viewBoxRef.current || !isDragging.current) return;
                e.preventDefault();

                startPoint.current.pendingX = e.clientX;
                startPoint.current.pendingY = e.clientY;

                if (rafId.current) return; // frame already queued

                rafId.current = requestAnimationFrame(() => {
                    rafId.current = null;
                    const sp = startPoint.current;
                    const dx = sp.pendingX - sp.x;
                    const dy = sp.pendingY - sp.y;
                    sp.x = sp.pendingX;
                    sp.y = sp.pendingY;

                    const svg = svgElRef.current;
                    if (!svg) return;
                    const screenW = svg.getBoundingClientRect().width;
                    const vb = viewBoxRef.current;
                    const scale = vb.w / screenW;

                    const newVb = {
                        ...vb,
                        x: vb.x - dx * scale,
                        y: vb.y - dy * scale
                    };
                    viewBoxRef.current = newVb;
                    applyViewBox(newVb);
                });
            };

            const handleMouseUp = () => {
                isDragging.current = false;
                if (rafId.current) {
                    cancelAnimationFrame(rafId.current);
                    rafId.current = null;
                }
                commitViewBox(); // Sync to React state on drag end
            };

            // Stable event registration — re-registers when active tab changes
            // OR when the diagram loads (initialViewBox changes). This handles the
            // case where the tab becomes active before the SVG is loaded (e.g. N-1
            // "Generating..." placeholder): events re-attach when the SVG appears.
            useEffect(() => {
                const el = svgRef.current;
                if (!el || !active) return;

                // Re-apply saved viewBox to the DOM when becoming active again
                // (e.g. returning from the overflow tab). The container stays
                // mounted so the ref is valid, but the SVG viewBox attribute may
                // need refreshing after being hidden.
                if (viewBoxRef.current) {
                    applyViewBox(viewBoxRef.current);
                }

                el.addEventListener('wheel', handleWheel, { passive: false });
                el.addEventListener('mousedown', handleMouseDown);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);

                return () => {
                    el.removeEventListener('wheel', handleWheel);
                    el.removeEventListener('mousedown', handleMouseDown);
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                    clearTimeout(wheelTimerId.current);
                    if (rafId.current) cancelAnimationFrame(rafId.current);
                };
            }, [active, initialViewBox]);

            // Public API: updates ref + DOM + React state immediately
            const setViewBoxPublic = (vb) => {
                viewBoxRef.current = vb;
                applyViewBox(vb);
                setViewBox(vb);
            };

            return { viewBox, setViewBox: setViewBoxPublic };
        };

        // Scale SVG elements for large grids so text, nodes, and flow values
        // are readable when zoomed in and naturally shrink at full view.
        // Uses DOMParser for in-place DOM manipulation instead of regex on
        // multi-MB strings, avoiding large temporary string copies.
        const boostSvgForLargeGrid = (svgString, viewBox, vlCount) => {
            if (!viewBox) return svgString;

            // Skip boost entirely for grids with < 500 voltage levels —
            // smaller grids render well at native pypowsybl sizes.
            if (!vlCount || vlCount < 500) return svgString;

            const diagramSize = Math.max(viewBox.w, viewBox.h);
            const REFERENCE_SIZE = 1250; // small grid where everything is readable
            const BOOST_THRESHOLD = 3;   // ratio above which we start boosting
            const ratio = diagramSize / REFERENCE_SIZE;
            if (ratio <= BOOST_THRESHOLD) return svgString; // viewBox too small for boost

            // Normalized boost: starts at 1.0 at threshold, increases gradually.
            // ratio=4 → 1.15, ratio=6 → 1.41, ratio=9 → 1.73, ratio=12 → 2.0
            const boost = Math.sqrt(ratio / BOOST_THRESHOLD);
            console.log(`[SVG] vlCount=${vlCount}, viewBox ${diagramSize.toFixed(0)}, ratio ${ratio.toFixed(2)}, boost ${boost.toFixed(2)}`);

            const parser = new DOMParser();
            const doc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgEl = doc.documentElement;

            // Only enable text-hiding for genuinely large grids where text is
            // unreadable at full zoom-out (~4px on screen). Decoupled from
            // the boost threshold so medium-large grids keep text always visible.
            if (ratio > 6) {
                svgEl.setAttribute('data-large-grid', 'true');
            }

            // === 1. Scale CSS values in <style> blocks ===
            const styles = svgEl.querySelectorAll('style');
            styles.forEach(style => {
                let css = style.textContent;
                // Node label font
                css = css.replace(/font:\s*25px\s+serif/, `font: ${Math.round(25 * boost)}px serif`);
                // Label box padding and border-radius
                css = css.replace(
                    'padding: 10px; border-radius: 10px;',
                    `padding: ${Math.round(10 * boost)}px; border-radius: ${Math.round(10 * boost)}px;`
                );
                // Legend square sizes
                css = css.replace(
                    'margin-right: 10px; width: 20px; height: 20px;',
                    `margin-right: ${Math.round(10 * boost)}px; width: ${Math.round(20 * boost)}px; height: ${Math.round(20 * boost)}px;`
                );
                style.textContent = css;
            });

            // === 2. Scale node groups (circles + inner bus sectors/paths) ===
            // Scale the entire parent <g> so both the outer circle AND inner
            // path sectors (multi-bus VLs like PYMONP3) scale uniformly.
            const scaledGroups = new Set();
            svgEl.querySelectorAll('circle').forEach(circle => {
                const g = circle.parentElement;
                if (!g || g.tagName !== 'g' || scaledGroups.has(g)) return;
                // Skip groups containing labels — those scale via CSS
                if (g.querySelector('foreignObject')) return;
                scaledGroups.add(g);
                const cx = parseFloat(circle.getAttribute('cx')) || 0;
                const cy = parseFloat(circle.getAttribute('cy')) || 0;
                const t = g.getAttribute('transform') || '';
                g.setAttribute('transform',
                    `${t} translate(${cx},${cy}) scale(${boost.toFixed(2)}) translate(${-cx},${-cy})`);
            });

            // === 3. Scale edge-info group transforms (flow arrows + values) ===
            // DON'T scale the edge-info CSS font separately — the transform handles it.
            const edgeInfoGroup = svgEl.querySelector('.nad-edge-infos');
            if (edgeInfoGroup) {
                edgeInfoGroup.querySelectorAll(':scope > g[transform]').forEach(g => {
                    const t = g.getAttribute('transform');
                    if (t && t.includes('translate(') && !t.includes('scale(')) {
                        g.setAttribute('transform', t + ` scale(${boost.toFixed(2)})`);
                    }
                });
            }

            return new XMLSerializer().serializeToString(svgEl);
        };

        // Build Map indices from metadata for O(1) lookups in zoomToElement
        const buildMetadataIndex = (metadata) => {
            if (!metadata) return null;
            const meta = typeof metadata === 'string' ? JSON.parse(metadata) : metadata;
            const nodes = meta.nodes || [];
            const edges = meta.edges || [];

            const nodesByEquipmentId = new Map();
            const nodesBySvgId = new Map();
            const edgesByEquipmentId = new Map();
            const edgesByNode = new Map(); // svgId -> [edge, ...]

            nodes.forEach(n => {
                nodesByEquipmentId.set(n.equipmentId, n);
                nodesBySvgId.set(n.svgId, n);
            });

            edges.forEach(e => {
                edgesByEquipmentId.set(e.equipmentId, e);
                if (!edgesByNode.has(e.node1)) edgesByNode.set(e.node1, []);
                edgesByNode.get(e.node1).push(e);
                if (!edgesByNode.has(e.node2)) edgesByNode.set(e.node2, []);
                edgesByNode.get(e.node2).push(e);
            });

            return { nodesByEquipmentId, nodesBySvgId, edgesByEquipmentId, edgesByNode };
        };

        // Apply orange highlights to overloaded line edges on a given SVG container
        const applyOverloadedHighlights = (container, metaIndex, overloadedLines) => {
            if (!container || !metaIndex || !overloadedLines || overloadedLines.length === 0) return;

            // Clear previous overloaded highlights
            container.querySelectorAll('.nad-overloaded').forEach(el => el.classList.remove('nad-overloaded'));

            const { edgesByEquipmentId } = metaIndex;
            overloadedLines.forEach(lineName => {
                const edge = edgesByEquipmentId.get(lineName);
                if (edge && edge.svgId) {
                    const el = container.querySelector(`[id="${edge.svgId}"]`);
                    if (el) el.classList.add('nad-overloaded');
                }
            });
        };

        // Determine which lines an action acts upon (for line disconnection/reconnection actions).
        // Returns an array of line names, or empty array if the action is not line-only.
        const getActionTargetLines = (actionDetail, actionId, edgesByEquipmentId) => {
            const topo = actionDetail?.action_topology;
            if (topo) {
                const lineKeys = new Set([
                    ...Object.keys(topo.lines_ex_bus || {}),
                    ...Object.keys(topo.lines_or_bus || {}),
                ]);
                const genKeys = Object.keys(topo.gens_bus || {});
                const loadKeys = Object.keys(topo.loads_bus || {});

                // No gen/load changes → line-only action
                if (lineKeys.size > 0 && genKeys.length === 0 && loadKeys.length === 0) {
                    return [...lineKeys];
                }

                // Multiple assets but ALL values are -1 → multiple line disconnections
                const allValues = [
                    ...Object.values(topo.lines_ex_bus || {}),
                    ...Object.values(topo.lines_or_bus || {}),
                    ...Object.values(topo.gens_bus || {}),
                    ...Object.values(topo.loads_bus || {}),
                ];
                if (allValues.length > 0 && allValues.every(v => v === -1)) {
                    return [...lineKeys];
                }
            }

            // Fallback: parse actionId if topology yielded nothing (e.g. reco_CHALOL31LOUHA)
            if (actionId) {
                const parts = actionId.split('_');
                const candidate = parts[parts.length - 1];
                if (edgesByEquipmentId && edgesByEquipmentId.has(candidate)) {
                    return [candidate];
                }
            }

            return [];
        };

        // Extract the voltage level name for nodal actions.
        const getActionTargetVoltageLevel = (actionDetail, actionId, nodesByEquipmentId) => {
            const desc = actionDetail?.description_unitaire;
            if (desc && desc !== 'No description available') {
                // Try all quoted strings (last-first) — any might be the VL name
                const quotedMatches = desc.match(/'([^']+)'/g);
                if (quotedMatches) {
                    for (let i = quotedMatches.length - 1; i >= 0; i--) {
                        const vl = quotedMatches[i].replace(/'/g, '');
                        if (nodesByEquipmentId.has(vl)) return vl;
                    }
                }
                // Match "dans le poste", "du poste", "au poste", etc.
                const posteMatch = desc.match(/(?:dans le |du |au )?poste\s+'?(\S+?)'?(?:\s|$|,)/i);
                if (posteMatch) {
                    const vl = posteMatch[1].replace(/['"]/g, '');
                    if (nodesByEquipmentId.has(vl)) return vl;
                }
            }

            // Fallback: action ID suffix — skip for pure line reconnection actions
            // (where lines are reconnected to real buses ≥ 0 with no gen/load changes),
            // because the suffix can coincidentally match a VL name.
            const topo = actionDetail?.action_topology;
            const isLineReconnection = topo
                && (Object.keys(topo.gens_bus || {}).length === 0 && Object.keys(topo.loads_bus || {}).length === 0)
                && [...Object.values(topo.lines_ex_bus || {}), ...Object.values(topo.lines_or_bus || {})].some(v => v >= 0);

            if (actionId && !isLineReconnection) {
                const parts = actionId.split('_');
                const candidate = parts[parts.length - 1];
                if (nodesByEquipmentId.has(candidate)) return candidate;
            }
            return null;
        };

        // Apply yellow fluo halo to action targets: edges (line actions) or nodes (nodal actions)
        const applyActionTargetHighlights = (container, metaIndex, actionDetail, actionId) => {
            if (!container) return;
            container.querySelectorAll('.nad-action-target').forEach(el => el.classList.remove('nad-action-target'));
            container.querySelectorAll('.nad-highlight-clone').forEach(el => el.remove());
            if (!metaIndex || !actionDetail) return;

            const { edgesByEquipmentId, nodesByEquipmentId } = metaIndex;
            console.log('[action-target] actionId:', actionId, 'desc:', actionDetail?.description_unitaire);

            // Create or find background layer at the root of the SVG
            let backgroundLayer = container.querySelector('#nad-background-layer');
            if (!backgroundLayer) {
                // backgroundLayer must be child of the SVG element, which is `container` in standalone?
                // Wait, in standalone `container` is the wrapper div. The SVG is inside.
                const svg = container.querySelector('svg');
                if (svg) {
                    backgroundLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    backgroundLayer.setAttribute('id', 'nad-background-layer');
                    if (svg.firstChild) {
                        svg.insertBefore(backgroundLayer, svg.firstChild);
                    } else {
                        svg.appendChild(backgroundLayer);
                    }
                }
            }

            // Helper to apply highlight
            const applyHighlight = (el) => {
                if (!el) return;

                // Clone and move to background layer
                if (backgroundLayer) {
                    const clone = el.cloneNode(true);
                    clone.removeAttribute('id');
                    clone.classList.add('nad-action-target');
                    clone.classList.add('nad-highlight-clone');

                    try {
                        const elCTM = el.getScreenCTM();
                        const bgCTM = backgroundLayer.getScreenCTM();
                        if (elCTM && bgCTM) {
                            const relativeCTM = bgCTM.inverse().multiply(elCTM);
                            const matrixStr = `matrix(${relativeCTM.a}, ${relativeCTM.b}, ${relativeCTM.c}, ${relativeCTM.d}, ${relativeCTM.e}, ${relativeCTM.f})`;
                            clone.setAttribute('transform', matrixStr);
                        }
                    } catch (e) {
                        console.warn('Failed to get CTM for highlight:', e);
                    }
                    backgroundLayer.appendChild(clone);
                } else {
                    // Fallback if no background layer (shouldn't happen)
                    el.classList.add('nad-action-target');
                }
            };

            // 1. Try VL detection first (handles nodal AND coupler actions)
            const vlName = getActionTargetVoltageLevel(actionDetail, actionId, nodesByEquipmentId);
            console.log('[action-target] VL result:', vlName);
            if (vlName) {
                const node = nodesByEquipmentId.get(vlName);
                console.log('[action-target] node svgId:', node?.svgId);
                if (node && node.svgId) {
                    const el = container.querySelector(`[id="${node.svgId}"]`);
                    console.log('[action-target] SVG element found:', !!el);
                    if (el) {
                        applyHighlight(el);
                        return;
                    }
                }
            }

            // 2. Fall back to line action: highlight edges from topology or action ID
            const targetLines = getActionTargetLines(actionDetail, actionId, edgesByEquipmentId);
            targetLines.forEach(lineName => {
                const edge = edgesByEquipmentId.get(lineName);
                if (edge && edge.svgId) {
                    const el = container.querySelector(`[id="${edge.svgId}"]`);
                    applyHighlight(el);
                }
            });
        };

        function App() {
            const [networkPath, setNetworkPath] = useState(localStorage.getItem('networkPath') || '/home/marotant/dev/Expert_op4grid_recommender/data/bare_env_20240828T0100Z_dijon_only');
            const [actionPath, setActionPath] = useState(localStorage.getItem('actionPath') || '/home/marotant/dev/Expert_op4grid_recommender/data/action_space/reduced_model_actions_20240828T0100Z_new_dijon.json');
            const [linesMonitoringPath, setLinesMonitoringPath] = useState(localStorage.getItem('linesMonitoringPath') || '');
            const initialMountRef = useRef(true);

            const [branches, setBranches] = useState([]);
            const [voltageLevels, setVoltageLevels] = useState([]);

            // Nominal voltage filter state
            const [nominalVoltageMap, setNominalVoltageMap] = useState({});  // {vl_id: kv}
            const [uniqueVoltages, setUniqueVoltages] = useState([]);       // sorted [kv1, kv2, ...]
            const [voltageRange, setVoltageRange] = useState([0, 400]);     // [minKv, maxKv] cursor positions
            const [selectedBranch, setSelectedBranch] = useState('');
            const [configLoading, setConfigLoading] = useState(false);

            // Recommender Settings
            const [minLineReconnections, setMinLineReconnections] = useState(2.0);
            const [minCloseCoupling, setMinCloseCoupling] = useState(3.0);
            const [minOpenCoupling, setMinOpenCoupling] = useState(2.0);
            const [minLineDisconnections, setMinLineDisconnections] = useState(3.0);
            const [nPrioritizedActions, setNPrioritizedActions] = useState(10);
            const [monitoringFactor, setMonitoringFactor] = useState(0.95);
            const [preExistingOverloadThreshold, setPreExistingOverloadThreshold] = useState(0.02);
            const [monitoredLinesCount, setMonitoredLinesCount] = useState(0);
            const [totalLinesCount, setTotalLinesCount] = useState(0);
            const [showMonitoringWarning, setShowMonitoringWarning] = useState(false);

            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [settingsTab, setSettingsTab] = useState('recommender');
            const [settingsBackup, setSettingsBackup] = useState(null);
            const [analysisLoading, setAnalysisLoading] = useState(false);
            const [analysisRan, setAnalysisRan] = useState(false);
            const [manualActionIds, setManualActionIds] = useState(new Set());
            const [pendingAnalysisResult, setPendingAnalysisResult] = useState(null);

            const handleOpenSettings = () => {
                setSettingsBackup({
                    minLineReconnections,
                    minCloseCoupling,
                    minOpenCoupling,
                    minLineDisconnections,
                    nPrioritizedActions,
                    linesMonitoringPath,
                    monitoringFactor,
                    preExistingOverloadThreshold
                });
                setIsSettingsOpen(true);
            };

            const handleCloseSettings = () => {
                if (settingsBackup) {
                    setMinLineReconnections(settingsBackup.minLineReconnections);
                    setMinCloseCoupling(settingsBackup.minCloseCoupling);
                    setMinOpenCoupling(settingsBackup.minOpenCoupling);
                    setMinLineDisconnections(settingsBackup.minLineDisconnections);
                    setNPrioritizedActions(settingsBackup.nPrioritizedActions);
                    setLinesMonitoringPath(settingsBackup.linesMonitoringPath);
                    setMonitoringFactor(settingsBackup.monitoringFactor);
                    setPreExistingOverloadThreshold(settingsBackup.preExistingOverloadThreshold);
                }
                setIsSettingsOpen(false);
            };

            const handleApplySettings = async () => {
                try {
                    const configRes = await axios.post(API_BASE + '/api/config', {
                        network_path: networkPath,
                        action_file_path: actionPath,
                        min_line_reconnections: minLineReconnections,
                        min_close_coupling: minCloseCoupling,
                        min_open_coupling: minOpenCoupling,
                        min_line_disconnections: minLineDisconnections,
                        n_prioritized_actions: nPrioritizedActions,
                        lines_monitoring_path: linesMonitoringPath,
                        monitoring_factor: monitoringFactor,
                        pre_existing_overload_threshold: preExistingOverloadThreshold
                    });

                    if (configRes.data && configRes.data.total_lines_count !== undefined) {
                        setMonitoredLinesCount(configRes.data.monitored_lines_count);
                        setTotalLinesCount(configRes.data.total_lines_count);
                        setShowMonitoringWarning(true);
                    }

                    setSettingsBackup({
                        minLineReconnections,
                        minCloseCoupling,
                        minOpenCoupling,
                        minLineDisconnections,
                        nPrioritizedActions,
                        linesMonitoringPath,
                        monitoringFactor,
                        preExistingOverloadThreshold
                    });
                    setInfoMessage('Settings applied successfully. Reloading network state...');
                    setIsSettingsOpen(false);

                    // Re-fetch configuration and overloads to reflect limits change
                    handleLoadConfig();
                } catch (err) {
                    setError('Failed to apply settings: ' + (err.response?.data?.detail || err.message));
                }
            };
            const [error, setError] = useState('');
            const [result, setResult] = useState(null);
            const [infoMessage, setInfoMessage] = useState('');
            const [inspectQuery, setInspectQuery] = useState('');

            // Visualization State
            const [activeTab, setActiveTab] = useState('n'); // 'n', 'n-1', 'overflow'
            const activeTabRef = useRef(activeTab);
            // useLayoutEffect to ensure ref is updated before any layout effects (like svg-pan-zoom) run
            useLayoutEffect(() => { activeTabRef.current = activeTab; }, [activeTab]);
            const prevTabRef = useRef(activeTab);

            const [nDiagram, setNDiagram] = useState(null);
            const [n1Diagram, setN1Diagram] = useState(null);
            const [n1Loading, setN1Loading] = useState(false);

            // Action variant diagram state
            const [selectedActionId, setSelectedActionId] = useState(null);
            const [actionDiagram, setActionDiagram] = useState(null);
            const [actionDiagramLoading, setActionDiagramLoading] = useState(false);

            // Manual action search state
            const [searchOpen, setSearchOpen] = useState(false);
            const [searchQuery, setSearchQuery] = useState('');
            const [availableActions, setAvailableActions] = useState([]);
            const [loadingAvailableActions, setLoadingAvailableActions] = useState(false);
            const [simulatingActionId, setSimulatingActionId] = useState(null);
            const [searchError, setSearchError] = useState('');
            const [typeFilters, setTypeFilters] = useState({ disco: true, reco: true, open: true, close: true });
            const searchDropdownRef = useRef(null);
            const searchInputRef = useRef(null);
            const [scoreTooltip, setScoreTooltip] = useState(null);

            const showScoreTooltip = (e, content) => {
                const rect = e.currentTarget.getBoundingClientRect();
                setScoreTooltip({ content, x: rect.left, y: rect.bottom + 5 });
            };
            const hideScoreTooltip = () => setScoreTooltip(null);

            // Delta visualization mode
            const [actionViewMode, setActionViewMode] = useState('network'); // 'network' or 'delta'

            // VL overlay popup: { vlName, actionId, svg, loading, error }
            const [vlOverlay, setVlOverlay] = useState(null);
            const [overlayTransform, setOverlayTransform] = useState({ scale: 1, tx: 0, ty: 0 });
            const [overlayPos, setOverlayPos] = useState({ x: 16, y: 16 });
            const overlayBodyRef = useRef(null);

            const [originalViewBox, setOriginalViewBox] = useState(null);

            // Container ref for clamping the SLD overlay drag
            const vizContainerRef = useRef(null);

            // Independent Refs for N, N-1, and Action Variant
            const nSvgContainerRef = useRef(null);
            const n1SvgContainerRef = useRef(null);
            const actionSvgContainerRef = useRef(null);

            // Native Pan/Zoom Instances
            const nPZ = usePanZoom(nSvgContainerRef, nDiagram?.originalViewBox, activeTab === 'n');
            const n1PZ = usePanZoom(n1SvgContainerRef, n1Diagram?.originalViewBox, activeTab === 'n-1');
            const actionPZ = usePanZoom(actionSvgContainerRef, actionDiagram?.originalViewBox, activeTab === 'action');

            // View State Management for Synchronization
            const lastViewStateN = useRef(null); // { zoom, pan: {x, y} }
            const lastViewStateN1 = useRef(null); // { zoom, pan: {x, y} }
            const lastZoomState = useRef({ query: '', branch: '' }); // Tracks last auto-zoom triggers
            // Captured viewBox to re-apply after the action diagram loads
            // (the tab-switch sync fires before the SVG exists, then
            // usePanZoom resets to the diagram's native viewBox).
            const actionSyncSourceRef = useRef(null);


            useEffect(() => { localStorage.setItem('networkPath', networkPath); }, [networkPath]);
            useEffect(() => { localStorage.setItem('actionPath', actionPath); }, [actionPath]);
            useEffect(() => { localStorage.setItem('linesMonitoringPath', linesMonitoringPath); }, [linesMonitoringPath]);

            const pickPath = async (type, setter) => {
                try {
                    const res = await axios.get(`${API_BASE}/api/pick-path?type=${type}`);
                    if (res.data.path) setter(res.data.path);
                } catch (err) { setError('Failed to open file picker'); }
            };

            const handleLoadConfig = async () => {
                setConfigLoading(true); setError(''); setInfoMessage('');
                setNDiagram(null); setN1Diagram(null); setResult(null);
                setSelectedActionId(null); setActionDiagram(null);
                setActiveTab('n');
                lastViewStateN.current = null; // Reset view state on new config
                lastViewStateN1.current = null;
                lastZoomState.current = { query: '', branch: '' };

                try {
                    const configRes = await axios.post(API_BASE + '/api/config', {
                        network_path: networkPath,
                        action_file_path: actionPath,
                        min_line_reconnections: minLineReconnections,
                        min_close_coupling: minCloseCoupling,
                        min_open_coupling: minOpenCoupling,
                        min_line_disconnections: minLineDisconnections,
                        n_prioritized_actions: nPrioritizedActions,
                        lines_monitoring_path: linesMonitoringPath,
                        monitoring_factor: monitoringFactor,
                        pre_existing_overload_threshold: preExistingOverloadThreshold
                    });

                    if (configRes.data && configRes.data.total_lines_count !== undefined) {
                        setMonitoredLinesCount(configRes.data.monitored_lines_count);
                        setTotalLinesCount(configRes.data.total_lines_count);
                        setShowMonitoringWarning(true);
                    }

                    const [branchesRes, vlRes, nomVRes] = await Promise.all([
                        axios.get(API_BASE + '/api/branches'),
                        axios.get(API_BASE + '/api/voltage-levels'),
                        axios.get(API_BASE + '/api/nominal-voltages')
                    ]);

                    setBranches(branchesRes.data.branches);
                    setVoltageLevels(vlRes.data.voltage_levels);

                    // Set up nominal voltage filter
                    const nvMap = nomVRes.data.mapping;
                    const uniqueKv = nomVRes.data.unique_kv;
                    setNominalVoltageMap(nvMap);
                    setUniqueVoltages(uniqueKv);
                    if (uniqueKv.length > 0) {
                        setVoltageRange([uniqueKv[0], uniqueKv[uniqueKv.length - 1]]);
                    }

                    fetchBaseDiagram(vlRes.data.voltage_levels.length);
                } catch (err) {
                    setError('Failed to load config: ' + (err.response?.data?.detail || err.message));
                } finally { setConfigLoading(false); }
            };

            // We no longer automatically reload config when settings close, 
            // the user must explicitly click Apply in settings.

            const processSvg = (rawSvg, vlCount) => {
                const match = rawSvg.match(/viewBox=["']([^"']+)["']/);
                let vb = null;
                if (match) {
                    const parts = match[1].split(/\s+|,/).map(parseFloat);
                    if (parts.length === 4) vb = { x: parts[0], y: parts[1], w: parts[2], h: parts[3] };
                }

                // Diagnostic: log SVG root attributes and embedded CSS for debugging
                const svgTag = rawSvg.match(/<svg[^>]*>/)?.[0] || '';
                const widthMatch = svgTag.match(/\bwidth=["']([^"']+)["']/);
                const heightMatch = svgTag.match(/\bheight=["']([^"']+)["']/);
                console.log(`[SVG processSvg] vlCount=${vlCount}, viewBox=${vb ? `${vb.w.toFixed(0)}x${vb.h.toFixed(0)}` : 'none'}, svgWidth=${widthMatch?.[1] || 'none'}, svgHeight=${heightMatch?.[1] || 'none'}`);

                // Boost text/label sizes for large grids before injection
                const svg = boostSvgForLargeGrid(rawSvg, vb, vlCount);
                return { svg, viewBox: vb };
            };
            const handleManualZoomIn = () => {
                const currentPZ = activeTab === 'action' ? actionPZ : activeTab === 'n' ? nPZ : n1PZ;
                const vb = currentPZ?.viewBox;
                if (currentPZ && vb) {
                    const scale = 0.8;
                    currentPZ.setViewBox({
                        x: vb.x + vb.w * (1 - scale) / 2,
                        y: vb.y + vb.h * (1 - scale) / 2,
                        w: vb.w * scale,
                        h: vb.h * scale,
                    });
                }
            };

            const handleManualZoomOut = () => {
                const currentPZ = activeTab === 'action' ? actionPZ : activeTab === 'n' ? nPZ : n1PZ;
                const vb = currentPZ?.viewBox;
                if (currentPZ && vb) {
                    const scale = 1.25;
                    currentPZ.setViewBox({
                        x: vb.x + vb.w * (1 - scale) / 2,
                        y: vb.y + vb.h * (1 - scale) / 2,
                        w: vb.w * scale,
                        h: vb.h * scale,
                    });
                }
            };

            const handleManualReset = () => {
                setInspectQuery('');

                const currentPZ = activeTab === 'action' ? actionPZ : activeTab === 'n' ? nPZ : n1PZ;
                const currentDiagram = activeTab === 'action' ? actionDiagram : activeTab === 'n' ? nDiagram : n1Diagram;
                const viewBox = currentDiagram?.originalViewBox || originalViewBox;

                if (currentPZ && viewBox) {
                    currentPZ.setViewBox(viewBox);
                    lastZoomState.current = { query: '', branch: '' };
                }

                // Clear highlights
                const container = activeTab === 'action' ? actionSvgContainerRef.current
                    : activeTab === 'n' ? nSvgContainerRef.current : n1SvgContainerRef.current;
                if (container) {
                    container.querySelectorAll('.nad-highlight').forEach(el => el.classList.remove('nad-highlight'));
                }
            };

            const fetchBaseDiagram = async (vlCount) => {
                try {
                    const res = await axios.get(API_BASE + '/api/network-diagram');
                    const { svg, viewBox } = processSvg(res.data.svg, vlCount || 0);
                    if (viewBox) setOriginalViewBox(viewBox);
                    setNDiagram({ ...res.data, svg, originalViewBox: viewBox });
                } catch (err) { console.error('Failed to fetch diagram:', err); }
            };

            // Fetch N-1 Diagram when contingency is selected (ONLY if valid branch)
            useEffect(() => {
                if (!selectedBranch) {
                    setN1Diagram(null);
                    return;
                }

                // Prevent fetching if the branch is not in the valid list (e.g. user is still typing)
                if (branches.length > 0 && !branches.includes(selectedBranch)) {
                    return;
                }

                const fetchN1 = async () => {
                    setN1Loading(true);
                    setActiveTab('n-1'); // Switch immediately → shows "Generating N-1 Diagram..."
                    try {
                        const res = await axios.post(API_BASE + '/api/n1-diagram', { disconnected_element: selectedBranch });
                        const { svg, viewBox } = processSvg(res.data.svg, voltageLevels.length);
                        setN1Diagram({ ...res.data, svg, originalViewBox: viewBox }); // Embed viewBox
                    } catch (err) {
                        console.error("Failed to fetch N-1 diagram", err);
                        setError(`Failed to fetch N-1 diagram for ${selectedBranch}`);
                    } finally {
                        setN1Loading(false);
                    }
                };
                fetchN1();
            }, [selectedBranch, branches]);

            // Auto-switch to overflow tab when analysis runs
            const handleRunAnalysis = async () => {
                if (!selectedBranch) return;
                setAnalysisLoading(true); setError(''); setInfoMessage('');
                setAnalysisRan(false);
                setPendingAnalysisResult(null);
                // Keep result (manual actions) intact — don't clear it
                setActiveTab('overflow');

                try {
                    const response = await fetch(API_BASE + '/api/run-analysis', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ disconnected_element: selectedBranch })
                    });
                    if (!response.ok) throw new Error('Analysis failed');
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep incomplete line in buffer
                        for (const line of lines) {
                            if (!line.trim()) continue;
                            try {
                                const event = JSON.parse(line);
                                if (event.type === 'pdf') setResult(p => ({ ...p, pdf_url: event.pdf_url }));
                                else if (event.type === 'result') {
                                    // Store analysis result as pending — don't merge yet
                                    setPendingAnalysisResult(event);
                                    if (event.message) setInfoMessage(event.message);
                                }
                                else if (event.type === 'error') setError('Analysis failed: ' + event.message);
                            } catch (e) {
                                console.error('Stream error:', e);
                            }
                        }
                    }
                } catch (err) { setError('Analysis failed: ' + err.message); }
                finally { setAnalysisLoading(false); setAnalysisRan(true); }
            };

            // Merge pending analysis result with existing manual actions
            const handleDisplayPrioritizedActions = () => {
                if (!pendingAnalysisResult) return;
                setResult(prev => {
                    // Preserve manually added actions
                    const manualActionsData = {};
                    if (prev?.actions) {
                        for (const [id, data] of Object.entries(prev.actions)) {
                            if (manualActionIds.has(id)) {
                                manualActionsData[id] = data;
                            }
                        }
                    }
                    return {
                        ...pendingAnalysisResult,
                        actions: { ...pendingAnalysisResult.actions, ...manualActionsData },
                    };
                });
                setPendingAnalysisResult(null);
            };

            // Fetch action variant diagram when an action card is clicked
            const handleActionSelect = async (actionId) => {
                if (actionId === selectedActionId) {
                    // Deselect — return to previous diagram tab
                    setSelectedActionId(null);
                    setActionDiagram(null);
                    setActiveTab('n-1');
                    return;
                }

                // Capture current viewBox so we can re-apply it after the
                // action diagram loads (the tab-switch sync fires before
                // the SVG exists, then usePanZoom resets to the native
                // viewBox — we need to override that).
                actionSyncSourceRef.current =
                    (activeTabRef.current === 'action' ? actionPZ.viewBox : null)
                    || n1PZ.viewBox || nPZ.viewBox;

                setSelectedActionId(actionId);
                setActionDiagram(null);
                setActionDiagramLoading(true);
                setActiveTab('action');
                try {
                    const res = await axios.post(API_BASE + '/api/action-variant-diagram', { action_id: actionId });
                    const { svg, viewBox } = processSvg(res.data.svg, voltageLevels.length);
                    setActionDiagram({ ...res.data, svg, originalViewBox: viewBox });
                } catch (err) {
                    console.error('Failed to fetch action variant diagram:', err);
                    setError('Failed to fetch action variant diagram for ' + actionId);
                } finally {
                    setActionDiagramLoading(false);
                }
            };

            // ===== Asset Click (from action card badges / rho line names) =====
            const handleAssetClick = (actionId, assetName, tab = 'action') => {
                setInspectQuery(assetName);
                if (tab === 'n') {
                    setActiveTab('n');
                } else if (tab === 'n-1') {
                    setActiveTab('n-1');
                } else if (actionId !== selectedActionId) {
                    handleActionSelect(actionId);
                } else {
                    setActiveTab('action');
                }
            };

            // ===== VL Double-Click → Single Line Diagram overlay =====
            const handleVlDoubleClick = async (actionId, vlName) => {
                setOverlayTransform({ scale: 1, tx: 0, ty: 0 });
                setOverlayPos({ x: 16, y: 16 });
                setVlOverlay({ vlName, actionId, svg: null, loading: true, error: null });
                try {
                    const res = await axios.post(API_BASE + '/api/action-variant-sld', {
                        action_id: actionId,
                        voltage_level_id: vlName,
                    });
                    setVlOverlay(prev =>
                        prev && prev.vlName === vlName && prev.actionId === actionId
                            ? { ...prev, svg: res.data.svg, loading: false }
                            : prev
                    );
                } catch (err) {
                    setVlOverlay(prev => prev
                        ? { ...prev, loading: false, error: err?.response?.data?.detail || 'Failed to load diagram' }
                        : null
                    );
                }
            };

            // Wheel zoom on overlay body — must be non-passive to call preventDefault
            useEffect(() => {
                const el = overlayBodyRef.current;
                if (!el) return;
                const onWheel = (e) => {
                    e.preventDefault();
                    const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
                    const rect = el.getBoundingClientRect();
                    const cx = e.clientX - rect.left;
                    const cy = e.clientY - rect.top;
                    setOverlayTransform(prev => {
                        const s = Math.max(0.1, Math.min(10, prev.scale * factor));
                        return {
                            scale: s,
                            tx: cx - (cx - prev.tx) * (s / prev.scale),
                            ty: cy - (cy - prev.ty) * (s / prev.scale),
                        };
                    });
                };
                el.addEventListener('wheel', onWheel, { passive: false });
                return () => el.removeEventListener('wheel', onWheel);
            }, [vlOverlay]);

            // Mouse pan inside overlay body
            const startOverlayPan = (e) => {
                if (e.button !== 0) return;
                e.preventDefault();
                const x0 = e.clientX, y0 = e.clientY;
                const tx0 = overlayTransform.tx, ty0 = overlayTransform.ty;
                const onMove = (ev) => setOverlayTransform(prev => ({
                    ...prev, tx: tx0 + ev.clientX - x0, ty: ty0 + ev.clientY - y0,
                }));
                const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            };

            // Drag the overlay window by its title bar
            // Clamps so the title bar always stays within the visualization container.
            const startOverlayDrag = (e) => {
                if (e.button !== 0) return;
                e.preventDefault();
                const x0 = e.clientX, y0 = e.clientY;
                const px0 = overlayPos.x, py0 = overlayPos.y;
                const TITLE_H = 32; // approx title bar height in px
                const WIN_W = 440;  // overlay width in px
                const onMove = (ev) => {
                    let nx = px0 + ev.clientX - x0;
                    let ny = py0 + ev.clientY - y0;
                    if (vizContainerRef.current) {
                        const { width, height } = vizContainerRef.current.getBoundingClientRect();
                        // Keep at least 60 px of the header visible on each horizontal side
                        nx = Math.max(-(WIN_W - 60), Math.min(nx, width - 60));
                        // Keep top edge inside container, bottom not below last visible title row
                        ny = Math.max(0, Math.min(ny, height - TITLE_H));
                    }
                    setOverlayPos({ x: nx, y: ny });
                };
                const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            };

            // --- Manual Action Search Logic ---
            const handleOpenSearch = async () => {
                if (searchOpen) { setSearchOpen(false); return; }
                setSearchOpen(true);
                setSearchQuery('');
                setSearchError('');
                if (availableActions.length === 0) {
                    setLoadingAvailableActions(true);
                    try {
                        const res = await axios.get(API_BASE + '/api/actions');
                        setAvailableActions(res.data.actions || []);
                    } catch (err) {
                        setSearchError('Failed to load actions');
                    } finally {
                        setLoadingAvailableActions(false);
                    }
                }
                setTimeout(() => searchInputRef.current?.focus(), 50);
            };

            const handleAddManualAction = async (actionId) => {
                if (!selectedBranch) { setSearchError('Run an analysis first'); return; }
                setSimulatingActionId(actionId);
                setSearchError('');
                try {
                    const res = await axios.post(API_BASE + '/api/simulate-manual-action', {
                        action_id: actionId,
                        disconnected_element: selectedBranch
                    });
                    const detail = res.data;
                    // Track this as a manually added action
                    setManualActionIds(prev => new Set([...prev, actionId]));
                    // Merge into result
                    setResult(prev => {
                        const base = prev || { actions: {}, lines_overloaded: [] };
                        return {
                            ...base,
                            lines_overloaded: (base.lines_overloaded && base.lines_overloaded.length > 0) ? base.lines_overloaded : (detail.lines_overloaded || []),
                            actions: {
                                ...(base.actions || {}),
                                [actionId]: {
                                    description_unitaire: detail.description_unitaire,
                                    rho_before: detail.rho_before,
                                    rho_after: detail.rho_after,
                                    max_rho: detail.max_rho,
                                    max_rho_line: detail.max_rho_line,
                                    is_rho_reduction: detail.is_rho_reduction,
                                }
                            }
                        };
                    });
                    setSearchOpen(false);
                    setSearchQuery('');
                    handleActionSelect(actionId);
                } catch (err) {
                    setSearchError(err?.response?.data?.detail || 'Simulation failed');
                } finally {
                    setSimulatingActionId(null);
                }
            };

            // Close search dropdown on outside click
            useEffect(() => {
                if (!searchOpen) return;
                const handler = (e) => {
                    if (searchDropdownRef.current && !searchDropdownRef.current.contains(e.target)) {
                        setSearchOpen(false);
                    }
                };
                document.addEventListener('mousedown', handler);
                return () => document.removeEventListener('mousedown', handler);
            }, [searchOpen]);

            // Filter available actions for dropdown
            const filteredSearchActions = useMemo(() => {
                const q = searchQuery.toLowerCase();
                const existingIds = new Set(result?.actions ? Object.keys(result.actions) : []);
                return availableActions
                    .filter(a => !existingIds.has(a.id))
                    .filter(a => {
                        const t = a.type || 'unknown';
                        if ((t.includes('disco') || t.includes('open_line') || t.includes('open_load')) && !typeFilters.disco) return false;
                        if ((t.includes('reco') || t.includes('close_line') || t.includes('close_load')) && !typeFilters.reco) return false;
                        if (t.includes('open_coupling') && !typeFilters.open) return false;
                        if (t.includes('close_coupling') && !typeFilters.close) return false;
                        if (!typeFilters.disco && !typeFilters.reco && !typeFilters.open && !typeFilters.close) return false;
                        return true;
                    })
                    .filter(a => a.id.toLowerCase().includes(q) || (a.description || '').toLowerCase().includes(q))
                    .slice(0, 20);
            }, [searchQuery, availableActions, result?.actions, typeFilters]);

            // Format scored actions
            const scoredActionsList = useMemo(() => {
                if (!result?.action_scores) return [];
                const list = [];
                for (const [type, data] of Object.entries(result.action_scores)) {
                    // Apply filtering
                    if (type === 'line_disconnection' && !typeFilters.disco) continue;
                    if (type === 'line_reconnection' && !typeFilters.reco) continue;
                    if (type === 'open_coupling' && !typeFilters.open) continue;
                    if (type === 'close_coupling' && !typeFilters.close) continue;

                    const scores = data?.scores || {};
                    for (const [actionId, score] of Object.entries(scores)) {
                        list.push({ type, actionId, score: Number(score) });
                    }
                }
                return list.sort((a, b) => {
                    if (a.type !== b.type) {
                        if (a.type === 'line_disconnection') return 1;
                        if (b.type === 'line_disconnection') return -1;
                        return a.type.localeCompare(b.type);
                    }
                    return b.score - a.score;
                });
            }, [result?.action_scores, typeFilters]);



            // --- Synchronization Logic ---
            // When switching directly between N, N-1, and Action tabs, sync
            // the zoom/pan state so all diagram tabs show the same region.
            // When returning from the overflow tab, each tab keeps its own
            // saved zoom state.
            useEffect(() => {
                const prevTab = prevTabRef.current;
                prevTabRef.current = activeTab;

                // Don't sync when coming from / going to overflow
                if (prevTab === 'overflow' || activeTab === 'overflow') return;

                // Find the source viewBox from the previous tab
                const sourceVB = prevTab === 'n' ? nPZ.viewBox
                    : prevTab === 'n-1' ? n1PZ.viewBox
                        : prevTab === 'action' ? actionPZ.viewBox
                            : null;
                if (!sourceVB) return;

                // Apply to the new active tab
                if (activeTab === 'n' && nPZ.setViewBox) {
                    nPZ.setViewBox(sourceVB);
                } else if (activeTab === 'n-1' && n1PZ.setViewBox) {
                    n1PZ.setViewBox(sourceVB);
                } else if (activeTab === 'action' && actionPZ.setViewBox) {
                    actionPZ.setViewBox(sourceVB);
                }
            }, [activeTab]);

            // Re-sync after action diagram loads: usePanZoom's initialViewBox
            // effect resets to the diagram's native viewBox, so we override it
            // with the captured source viewBox from the tab the user was on.
            useEffect(() => {
                if (actionDiagram && activeTab === 'action' && actionSyncSourceRef.current) {
                    actionPZ.setViewBox(actionSyncSourceRef.current);
                    actionSyncSourceRef.current = null;
                }
            }, [actionDiagram]);

            // Pre-indexed metadata for O(1) lookups in zoomToElement
            const nMetaIndex = useMemo(() => buildMetadataIndex(nDiagram?.metadata), [nDiagram?.metadata]);
            const n1MetaIndex = useMemo(() => buildMetadataIndex(n1Diagram?.metadata), [n1Diagram?.metadata]);
            const actionMetaIndex = useMemo(() => buildMetadataIndex(actionDiagram?.metadata), [actionDiagram?.metadata]);

            // Highlight overloaded lines in orange on N-1 and Action diagrams,
            // and highlight acted-upon lines in yellow fluo on Action diagram.
            useEffect(() => {
                const overloadedLines = result?.lines_overloaded || [];

                // Helper to apply delta visuals
                const applyDeltaVisuals = (container, diagram, metaIndex) => {
                    if (!container || !diagram || !metaIndex) return;

                    // Clear delta classes
                    container.querySelectorAll('.nad-delta-positive').forEach(el => el.classList.remove('nad-delta-positive'));
                    container.querySelectorAll('.nad-delta-negative').forEach(el => el.classList.remove('nad-delta-negative'));
                    container.querySelectorAll('.nad-delta-grey').forEach(el => el.classList.remove('nad-delta-grey'));

                    // Restore original text labels
                    container.querySelectorAll('[data-original-text]').forEach(el => {
                        el.textContent = el.getAttribute('data-original-text');
                        el.removeAttribute('data-original-text');
                    });

                    // Resize delta logic
                    if (actionViewMode === 'delta' && diagram.flow_deltas) {
                        const { edgesByEquipmentId } = metaIndex;
                        const flowDeltas = diagram.flow_deltas;
                        const idMap = new Map();
                        container.querySelectorAll('[id]').forEach(el => idMap.set(el.id, el));

                        for (const [lineId, deltaInfo] of Object.entries(flowDeltas)) {
                            const edge = edgesByEquipmentId.get(lineId);
                            if (!edge || !edge.svgId) continue;

                            const el = idMap.get(edge.svgId);
                            if (el) {
                                const classMap = {
                                    positive: 'nad-delta-positive',
                                    negative: 'nad-delta-negative',
                                    grey: 'nad-delta-grey',
                                };
                                const cls = classMap[deltaInfo.category];
                                if (cls) el.classList.add(cls);
                            }

                            const deltaStr = deltaInfo.delta >= 0 ? `+${deltaInfo.delta.toFixed(1)}` : deltaInfo.delta.toFixed(1);
                            const edgeInfoIds = [edge.edgeInfo1?.svgId, edge.edgeInfo2?.svgId].filter(Boolean);

                            for (const infoSvgId of edgeInfoIds) {
                                const infoEl = idMap.get(infoSvgId);
                                if (!infoEl) continue;
                                const textTargets = infoEl.querySelectorAll('foreignObject, text');
                                textTargets.forEach(t => {
                                    if (!t.hasAttribute('data-original-text')) {
                                        t.setAttribute('data-original-text', t.textContent);
                                    }
                                    t.textContent = `Δ ${deltaStr}`;
                                });
                            }
                        }
                    }
                };

                // 1. N-1 Tab Logic
                if (activeTab === 'n-1') {
                    // Apply standard overloads ONLY if NOT in delta mode
                    if (actionViewMode !== 'delta' && n1SvgContainerRef.current && n1MetaIndex && overloadedLines.length > 0) {
                        applyOverloadedHighlights(n1SvgContainerRef.current, n1MetaIndex, overloadedLines);
                    }
                    // Apply delta visuals (clears logic if mode != delta)
                    applyDeltaVisuals(n1SvgContainerRef.current, n1Diagram, n1MetaIndex);
                }

                // 2. Action Tab Logic
                if (activeTab === 'action') {
                    // Apply delta visuals
                    applyDeltaVisuals(actionSvgContainerRef.current, actionDiagram, actionMetaIndex);

                    // Standard action highlights (Action targets & Overloads)
                    const actionDetail = result?.actions?.[selectedActionId];

                    if (actionDetail) {
                        if (actionViewMode !== 'delta') {
                            // Highlight overloads (post-action)
                            const stillOverloaded = [];
                            if (overloadedLines.length > 0 && actionDetail.rho_after) {
                                overloadedLines.forEach((name, i) => {
                                    if (actionDetail.rho_after[i] != null && actionDetail.rho_after[i] > 1.0) {
                                        stillOverloaded.push(name);
                                    }
                                });
                            }
                            if (actionDetail.max_rho != null && actionDetail.max_rho > 1.0 && actionDetail.max_rho_line) {
                                if (!stillOverloaded.includes(actionDetail.max_rho_line)) {
                                    stillOverloaded.push(actionDetail.max_rho_line);
                                }
                            }
                            applyOverloadedHighlights(actionSvgContainerRef.current, actionMetaIndex, stillOverloaded);
                        }

                        // Always highlight action targets (Yellow halo)
                        applyActionTargetHighlights(actionSvgContainerRef.current, actionMetaIndex, actionDetail, selectedActionId);
                    } else {
                        if (actionSvgContainerRef.current) applyActionTargetHighlights(actionSvgContainerRef.current, null, null, null);
                    }
                }

                // Standard diagram highlights
                if (nDiagram && activeTab === 'n') {
                    if (nSvgContainerRef.current) {
                        applyActionTargetHighlights(nSvgContainerRef.current, null, null, null);
                        const overloadedLines = nDiagram.lines_overloaded || [];
                        applyOverloadedHighlights(nSvgContainerRef.current, nMetaIndex, overloadedLines);
                    }
                } else if (n1Diagram && activeTab === 'n-1') {
                    // Apply standard overloads ONLY if NOT in delta mode
                    if (actionViewMode !== 'delta' && n1SvgContainerRef.current && n1MetaIndex && overloadedLines.length > 0) {
                        applyOverloadedHighlights(n1SvgContainerRef.current, n1MetaIndex, overloadedLines);
                    }
                    // Apply delta visuals (clears logic if mode != delta)
                    applyDeltaVisuals(n1SvgContainerRef.current, n1Diagram, n1MetaIndex);
                }

            }, [n1Diagram, actionDiagram, n1MetaIndex, actionMetaIndex, result, selectedActionId, actionViewMode, activeTab]);

            // ===== VOLTAGE RANGE FILTER =====
            // Hide/show SVG nodes and edges based on the nominal voltage range slider.
            useEffect(() => {
                if (uniqueVoltages.length === 0 || Object.keys(nominalVoltageMap).length === 0) return;

                const [minKv, maxKv] = voltageRange;

                // Helper: check if a voltage level ID falls within the range
                const isInRange = (vlId) => {
                    const kv = nominalVoltageMap[vlId];
                    return kv != null && kv >= minKv && kv <= maxKv;
                };

                // Apply filter to a single SVG container + its metadata index
                const applyFilter = (container, metaIndex) => {
                    if (!container || !metaIndex) return;
                    const { nodesByEquipmentId, nodesBySvgId, edgesByEquipmentId, edgesByNode } = metaIndex;

                    // Single DOM traversal for id→element map
                    const idMap = new Map();
                    container.querySelectorAll('[id]').forEach(el => idMap.set(el.id, el));

                    // Filter nodes (VL substations)
                    for (const [vlId, node] of nodesByEquipmentId) {
                        const visible = isInRange(vlId);
                        const show = visible ? '' : 'none';
                        const el = idMap.get(node.svgId);
                        if (el) el.style.display = show;
                        // Also hide legend box and legend edge
                        if (node.legendSvgId) {
                            const leg = idMap.get(node.legendSvgId);
                            if (leg) leg.style.display = show;
                        }
                        if (node.legendEdgeSvgId) {
                            const legE = idMap.get(node.legendEdgeSvgId);
                            if (legE) legE.style.display = show;
                        }
                    }

                    // Filter edges: hide only if BOTH endpoint VLs are outside range
                    for (const [eqId, edge] of edgesByEquipmentId) {
                        const node1 = nodesBySvgId.get(edge.node1);
                        const node2 = nodesBySvgId.get(edge.node2);
                        const vl1InRange = node1 ? isInRange(node1.equipmentId) : true;
                        const vl2InRange = node2 ? isInRange(node2.equipmentId) : true;
                        const edgeVisible = vl1InRange || vl2InRange;
                        const show = edgeVisible ? '' : 'none';

                        const el = idMap.get(edge.svgId);
                        if (el) el.style.display = show;
                        // Edge info labels
                        if (edge.edgeInfo1?.svgId) {
                            const ei = idMap.get(edge.edgeInfo1.svgId);
                            if (ei) ei.style.display = show;
                        }
                        if (edge.edgeInfo2?.svgId) {
                            const ei = idMap.get(edge.edgeInfo2.svgId);
                            if (ei) ei.style.display = show;
                        }
                    }
                };

                applyFilter(nSvgContainerRef.current, nMetaIndex);
                applyFilter(n1SvgContainerRef.current, n1MetaIndex);
                applyFilter(actionSvgContainerRef.current, actionMetaIndex);
            }, [voltageRange, nDiagram, n1Diagram, actionDiagram, nMetaIndex, n1MetaIndex, actionMetaIndex, nominalVoltageMap, uniqueVoltages]);

            // Zoom to an element by computing its bounding box from metadata
            const zoomToElement = (targetId) => {
                const currentPZ = activeTab === 'action' ? actionPZ : activeTab === 'n' ? nPZ : n1PZ;
                const container = activeTab === 'action' ? actionSvgContainerRef.current : activeTab === 'n' ? nSvgContainerRef.current : n1SvgContainerRef.current;
                const index = activeTab === 'action' ? actionMetaIndex : activeTab === 'n' ? nMetaIndex : n1MetaIndex;
                if (!currentPZ || !container || !index) return;

                try {
                    const { nodesByEquipmentId, nodesBySvgId, edgesByEquipmentId, edgesByNode } = index;
                    const points = [];

                    const addNodePointsBySvgId = (svgId) => {
                        const n = nodesBySvgId.get(svgId);
                        if (n) points.push({ x: n.x, y: n.y });
                        return n;
                    };

                    let targetNode = nodesByEquipmentId.get(targetId);
                    let targetEdge = edgesByEquipmentId.get(targetId);
                    // Fallback: strip prefix before "." (e.g. GEN.PY762 → PY762) and try as VL node
                    if (!targetNode && !targetEdge) {
                        const dotIdx = targetId.indexOf('.');
                        if (dotIdx >= 0) {
                            const suffix = targetId.substring(dotIdx + 1);
                            targetNode = nodesByEquipmentId.get(suffix);
                            if (!targetNode) targetEdge = edgesByEquipmentId.get(suffix);
                        }
                    }
                    let targetSvgId;

                    if (targetNode) {
                        targetSvgId = targetNode.svgId;
                        points.push({ x: targetNode.x, y: targetNode.y });
                        (edgesByNode.get(targetNode.svgId) || []).forEach(e => {
                            addNodePointsBySvgId(e.node1);
                            addNodePointsBySvgId(e.node2);
                        });
                    } else if (targetEdge) {
                        targetSvgId = targetEdge.svgId;
                        const n1 = addNodePointsBySvgId(targetEdge.node1);
                        const n2 = addNodePointsBySvgId(targetEdge.node2);
                        if (n1) (edgesByNode.get(n1.svgId) || []).forEach(e => { addNodePointsBySvgId(e.node1); addNodePointsBySvgId(e.node2); });
                        if (n2) (edgesByNode.get(n2.svgId) || []).forEach(e => { addNodePointsBySvgId(e.node1); addNodePointsBySvgId(e.node2); });
                    }

                    if (points.length > 0) {
                        const minX = Math.min(...points.map(p => p.x));
                        const maxX = Math.max(...points.map(p => p.x));
                        const minY = Math.min(...points.map(p => p.y));
                        const maxY = Math.max(...points.map(p => p.y));

                        const centerX = (minX + maxX) / 2;
                        const centerY = (minY + maxY) / 2;
                        const boxW = Math.max(maxX - minX, 50);
                        const boxH = Math.max(maxY - minY, 50);

                        const padding = 1.8;
                        const screenW = container.getBoundingClientRect().width;
                        const screenH = container.getBoundingClientRect().height;
                        const screenAR = screenW / screenH;

                        let targetW = boxW * padding;
                        let targetH = boxH * padding;

                        if (targetW / targetH > screenAR) {
                            targetH = targetW / screenAR;
                        } else {
                            targetW = targetH * screenAR;
                        }

                        const targetX = centerX - targetW / 2;
                        const targetY = centerY - targetH / 2;

                        currentPZ.setViewBox({ x: targetX, y: targetY, w: targetW, h: targetH });

                        // Highlight the target element
                        container.querySelectorAll('.nad-highlight').forEach(el => el.classList.remove('nad-highlight'));
                        if (targetSvgId) {
                            const el = container.querySelector(`[id="${targetSvgId}"]`);
                            if (el) el.classList.add('nad-highlight');
                        }
                    }
                } catch (e) { console.error('Zoom failed:', e); }
            };

            // Auto-zoom to selected element via viewBox
            useEffect(() => {
                if (activeTab === 'overflow') return;

                const queryChanged = inspectQuery !== lastZoomState.current.query;
                const branchChanged = !inspectQuery && selectedBranch !== lastZoomState.current.branch;

                if (!queryChanged && !branchChanged) return;

                let targetId = inspectQuery || selectedBranch;

                // Cleared inspect → reset view
                if (!targetId && queryChanged) {
                    lastZoomState.current = { query: inspectQuery, branch: selectedBranch };
                    handleManualReset();
                    return;
                }

                if (!targetId) return;

                // Branch changes should zoom on the N-1 tab, not N.
                // In the same render cycle, setActiveTab('n-1') is batched but
                // not committed — this effect still sees activeTab='n'. Skip here;
                // the effect re-runs when activeTab changes to 'n-1'.
                if (branchChanged && activeTab === 'n') return;

                // Only consume the zoom intent when the container has SVG content.
                // If not ready (e.g. N-1 still loading), skip — the effect re-runs
                // when n1Diagram changes, and branchChanged will still be true.
                const container = activeTab === 'action' ? actionSvgContainerRef.current
                    : activeTab === 'n' ? nSvgContainerRef.current : n1SvgContainerRef.current;
                if (!container || !container.querySelector('svg')) return;

                lastZoomState.current = { query: inspectQuery, branch: selectedBranch };
                zoomToElement(targetId);

            }, [activeTab, nDiagram, n1Diagram, actionDiagram, inspectQuery, selectedBranch]);



            const inspectableItems = [...branches, ...voltageLevels].sort();

            const renderVisualization = () => {
                return (
                    <div ref={vizContainerRef} style={{ width: '100%', height: '100%', position: 'relative' }}>
                        {/* Overflow Container */}
                        {activeTab === 'overflow' && (
                            <div style={{
                                width: '100%', height: '100%',
                                position: 'absolute', top: 0, left: 0,
                                backgroundColor: 'white', zIndex: 20
                            }}>
                                {result?.pdf_url || result?.plot_json ? (
                                    result.pdf_url ?
                                        <iframe src={API_BASE + result.pdf_url} key={result.pdf_url} style={{ width: '100%', height: '100%', border: 'none' }} />
                                        : <iframe srcDoc={result.plot_html} style={{ width: '100%', height: '100%', border: 'none' }} />
                                ) : (
                                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>
                                        {analysisLoading ? 'Processing Analysis...' : 'Run analysis to see overflow graph'}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* N Container — always mounted, hidden via CSS to preserve zoom state */}
                        <div style={{
                            width: '100%', height: '100%',
                            position: 'absolute', top: 0, left: 0,
                            zIndex: activeTab === 'n' ? 10 : -1,
                            visibility: activeTab === 'n' ? 'visible' : 'hidden',
                            pointerEvents: activeTab === 'n' ? 'auto' : 'none'
                        }}>
                            {nDiagram?.svg ?
                                <div className="svg-container" ref={nSvgContainerRef} dangerouslySetInnerHTML={{ __html: nDiagram.svg }} />
                                : <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Load configuration to see diagram</div>
                            }
                        </div>

                        {/* N-1 Container — always mounted, hidden via CSS to preserve zoom state */}
                        <div style={{
                            width: '100%', height: '100%',
                            position: 'absolute', top: 0, left: 0,
                            zIndex: activeTab === 'n-1' ? 10 : -1,
                            visibility: activeTab === 'n-1' ? 'visible' : 'hidden',
                            pointerEvents: activeTab === 'n-1' ? 'auto' : 'none'
                        }}>
                            {/* Convergence warning banner */}
                            {n1Diagram && n1Diagram.lf_converged === false && (
                                <div style={{
                                    position: 'absolute', top: 0, left: 0, right: 0, zIndex: 30,
                                    background: '#fff3cd', color: '#856404', padding: '6px 12px',
                                    fontSize: '0.8rem', borderBottom: '1px solid #ffc107',
                                    textAlign: 'center', pointerEvents: 'none'
                                }}>
                                    ⚠ AC load flow: {n1Diagram.lf_status || 'did not converge'} — voltage values may be missing or approximate
                                </div>
                            )}
                            {n1Loading ?
                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Generating N-1 Diagram...</div>
                                : (n1Diagram?.svg ?
                                    <div className="svg-container" ref={n1SvgContainerRef} dangerouslySetInnerHTML={{ __html: n1Diagram.svg }} />
                                    : <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Select a target contingency to view N-1</div>
                                )
                            }
                        </div>

                        {/* Action Variant Container — always mounted, hidden via CSS to preserve zoom state */}
                        <div style={{
                            width: '100%', height: '100%',
                            position: 'absolute', top: 0, left: 0,
                            zIndex: activeTab === 'action' ? 10 : -1,
                            visibility: activeTab === 'action' ? 'visible' : 'hidden',
                            pointerEvents: activeTab === 'action' ? 'auto' : 'none'
                        }}>
                            {/* Convergence warning banner */}
                            {actionDiagram && actionDiagram.lf_converged === false && (
                                <div style={{
                                    position: 'absolute', top: 0, left: 0, right: 0, zIndex: 30,
                                    background: '#fff3cd', color: '#856404', padding: '6px 12px',
                                    fontSize: '0.8rem', borderBottom: '1px solid #ffc107',
                                    textAlign: 'center', pointerEvents: 'none'
                                }}>
                                    ⚠ AC load flow: {actionDiagram.lf_status || 'did not converge'} — voltage values may be missing or approximate
                                </div>
                            )}
                            {actionDiagramLoading ?
                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Generating Action Variant Diagram...</div>
                                : (actionDiagram?.svg ?
                                    <div className="svg-container" ref={actionSvgContainerRef} dangerouslySetInnerHTML={{ __html: actionDiagram.svg }} />
                                    : (selectedActionId ?
                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Failed to load diagram for action {selectedActionId}</div>
                                        : <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999' }}>Select an action card to view its network variant</div>
                                    )
                                )
                            }
                        </div>
                        {uniqueVoltages.length > 1 && (() => {
                            const minV = uniqueVoltages[0];
                            const maxV = uniqueVoltages[uniqueVoltages.length - 1];
                            const logMin = Math.log(minV);
                            const logMax = Math.log(maxV);
                            const logScale = (kv) => ((Math.log(kv) - logMin) / (logMax - logMin)) * 100;
                            // For the vertical slider: 0% = bottom (low kV), 100% = top (high kV)
                            const pctLow = logScale(voltageRange[0]);
                            const pctHigh = logScale(voltageRange[1]);
                            return (
                                <div className="voltage-sidebar">
                                    <span className="vs-label">kV Filter</span>
                                    <span className="vs-range-label">
                                        {voltageRange[1]}<br />{voltageRange[0]}
                                    </span>
                                    <div className="voltage-slider-container">
                                        <div className="voltage-slider-track" />
                                        <div className="voltage-slider-range" style={{ bottom: pctLow + '%', top: (100 - pctHigh) + '%' }} />
                                        <input type="range"
                                            min={logMin} max={logMax} step="any"
                                            value={Math.log(voltageRange[0])}
                                            onChange={e => {
                                                const logV = parseFloat(e.target.value);
                                                const kv = Math.exp(logV);
                                                const snapped = uniqueVoltages.reduce((best, uv) => Math.abs(Math.log(uv) - logV) < Math.abs(Math.log(best) - logV) ? uv : best);
                                                if (snapped <= voltageRange[1]) setVoltageRange([snapped, voltageRange[1]]);
                                            }}
                                            style={{ zIndex: 3, height: '100%' }}
                                        />
                                        <input type="range"
                                            min={logMin} max={logMax} step="any"
                                            value={Math.log(voltageRange[1])}
                                            onChange={e => {
                                                const logV = parseFloat(e.target.value);
                                                const snapped = uniqueVoltages.reduce((best, uv) => Math.abs(Math.log(uv) - logV) < Math.abs(Math.log(best) - logV) ? uv : best);
                                                if (snapped >= voltageRange[0]) setVoltageRange([voltageRange[0], snapped]);
                                            }}
                                            style={{ zIndex: 4, height: '100%' }}
                                        />
                                        <div className="voltage-slider-ticks">
                                            {uniqueVoltages.map(kv => (
                                                <span key={kv} style={{
                                                    bottom: logScale(kv) + '%'
                                                }}>{kv}</span>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            );
                        })()}

                        {/* VL focused diagram overlay — appears in the bottom-right corner */}
                        {vlOverlay && (
                            <div style={{
                                position: 'absolute',
                                top: overlayPos.y + 'px',
                                left: overlayPos.x + 'px',
                                width: '440px',
                                height: '420px',
                                minWidth: '220px',
                                minHeight: '150px',
                                background: 'white',
                                border: '1px solid #ccc',
                                borderRadius: '8px',
                                boxShadow: '0 4px 24px rgba(0,0,0,0.22)',
                                zIndex: 45,
                                display: 'flex',
                                flexDirection: 'column',
                                overflow: 'hidden',
                                resize: 'both',
                                boxSizing: 'border-box',
                            }}>
                                {/* Header — drag handle */}
                                <div onMouseDown={startOverlayDrag} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '6px 10px', background: '#f0faf4', borderBottom: '1px solid #d1fae5', flexShrink: 0, cursor: 'move', userSelect: 'none' }}>
                                    <span style={{ fontSize: '12px', fontWeight: 600, color: '#065f46' }}>
                                        {vlOverlay.vlName} — post-action SLD
                                    </span>
                                    <button
                                        onClick={() => setVlOverlay(null)}
                                        style={{ background: 'none', border: 'none', cursor: 'pointer', fontSize: '16px', color: '#666', lineHeight: 1, padding: '0 2px' }}
                                        title="Close">✕</button>
                                </div>
                                {/* Body — pan/zoom canvas */}
                                <div ref={overlayBodyRef} className="vl-overlay-body"
                                    style={{ flex: 1, overflow: 'hidden', minHeight: 0, cursor: 'grab', userSelect: 'none' }}
                                    onMouseDown={startOverlayPan}>
                                    {vlOverlay.loading && (
                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#999', fontSize: '13px' }}>
                                            Generating diagram…
                                        </div>
                                    )}
                                    {vlOverlay.error && (
                                        <div style={{ padding: '12px', color: '#dc3545', fontSize: '12px' }}>{vlOverlay.error}</div>
                                    )}
                                    {vlOverlay.svg && (
                                        <div style={{
                                            transformOrigin: '0 0',
                                            transform: `translate(${overlayTransform.tx}px,${overlayTransform.ty}px) scale(${overlayTransform.scale})`,
                                            padding: '4px',
                                        }} dangerouslySetInnerHTML={{ __html: vlOverlay.svg }} />
                                    )}
                                </div>
                            </div>
                        )}
                    </div>
                );
            };



            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
                    <header>
                        <h2 style={{ margin: 0, fontSize: '1.1rem', whiteSpace: 'nowrap' }}>⚡ Expert Recommender</h2>
                        <div style={{ flex: '1 1 200px', display: 'flex', flexDirection: 'column', gap: '2px' }}>
                            <label>Network Path</label>
                            <div style={{ display: 'flex', gap: '4px' }}>
                                <input type="text" value={networkPath} onChange={e => setNetworkPath(e.target.value)} style={{ flex: 1, minWidth: 0 }} />
                                <button onClick={() => pickPath('dir', setNetworkPath)} style={{ padding: '4px 8px', background: 'rgba(255,255,255,0.15)', border: '1px solid rgba(255,255,255,0.25)', borderRadius: '4px', color: 'white', cursor: 'pointer', fontSize: '0.8rem' }}>📂</button>
                            </div>
                        </div>
                        <div style={{ flex: '1 1 200px', display: 'flex', flexDirection: 'column', gap: '2px' }}>
                            <label>Action File Path</label>
                            <div style={{ display: 'flex', gap: '4px' }}>
                                <input type="text" value={actionPath} onChange={e => setActionPath(e.target.value)} style={{ flex: 1, minWidth: 0 }} />
                                <button onClick={() => pickPath('file', setActionPath)} style={{ padding: '4px 8px', background: 'rgba(255,255,255,0.15)', border: '1px solid rgba(255,255,255,0.25)', borderRadius: '4px', color: 'white', cursor: 'pointer', fontSize: '0.8rem' }}>📄</button>
                            </div>
                        </div>
                        <button onClick={handleLoadConfig} disabled={configLoading} style={{ padding: '6px 14px', background: configLoading ? '#95a5a6' : '#3498db', color: 'white', border: 'none', borderRadius: '4px', cursor: configLoading ? 'not-allowed' : 'pointer', fontWeight: 'bold', fontSize: '0.8rem', whiteSpace: 'nowrap' }}>
                            {configLoading ? '⏳ Loading...' : '🔄 Load Study'}
                        </button>
                        <button onClick={handleOpenSettings} style={{ background: '#e67e22', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '6px 8px', fontSize: '1rem', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold' }} title="Settings">⚙️</button>
                    </header>

                    {
                        isSettingsOpen && (
                            <div style={{
                                position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                                backgroundColor: 'rgba(0,0,0,0.5)', zIndex: 2000,
                                display: 'flex', justifyContent: 'center', alignItems: 'center'
                            }}>
                                <div style={{
                                    background: 'white', padding: '25px', borderRadius: '8px',
                                    width: '400px', boxShadow: '0 4px 15px rgba(0,0,0,0.2)',
                                    display: 'flex', flexDirection: 'column', gap: '15px'
                                }}>
                                    <h3 style={{ margin: 0, borderBottom: '1px solid #eee', paddingBottom: '10px' }}>Recommender Settings</h3>

                                    <div style={{ display: 'flex', borderBottom: '1px solid #eee', marginBottom: '15px' }}>
                                        <button
                                            onClick={() => setSettingsTab('recommender')}
                                            style={{
                                                flex: 1, padding: '10px', cursor: 'pointer', background: 'none',
                                                border: 'none', borderBottom: settingsTab === 'recommender' ? '2px solid #3498db' : 'none',
                                                fontWeight: settingsTab === 'recommender' ? 'bold' : 'normal',
                                                color: settingsTab === 'recommender' ? '#3498db' : '#555'
                                            }}
                                        >
                                            Recommender
                                        </button>
                                        <button
                                            onClick={() => setSettingsTab('configurations')}
                                            style={{
                                                flex: 1, padding: '10px', cursor: 'pointer', background: 'none',
                                                border: 'none', borderBottom: settingsTab === 'configurations' ? '2px solid #3498db' : 'none',
                                                fontWeight: settingsTab === 'configurations' ? 'bold' : 'normal',
                                                color: settingsTab === 'configurations' ? '#3498db' : '#555'
                                            }}
                                        >
                                            Configurations
                                        </button>
                                    </div>

                                    {settingsTab === 'recommender' && (
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <label style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Min Line Reconnections</label>
                                                <input type="number" step="0.1" value={minLineReconnections} onChange={e => setMinLineReconnections(parseFloat(e.target.value))} style={{ width: '80px', padding: '5px' }} />
                                            </div>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <label style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Min Close Coupling</label>
                                                <input type="number" step="0.1" value={minCloseCoupling} onChange={e => setMinCloseCoupling(parseFloat(e.target.value))} style={{ width: '80px', padding: '5px' }} />
                                            </div>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <label style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Min Open Coupling</label>
                                                <input type="number" step="0.1" value={minOpenCoupling} onChange={e => setMinOpenCoupling(parseFloat(e.target.value))} style={{ width: '80px', padding: '5px' }} />
                                            </div>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <label style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Min Line Disconnections</label>
                                                <input type="number" step="0.1" value={minLineDisconnections} onChange={e => setMinLineDisconnections(parseFloat(e.target.value))} style={{ width: '80px', padding: '5px' }} />
                                            </div>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <label style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>N Prioritized Actions</label>
                                                <input type="number" step="1" value={nPrioritizedActions} onChange={e => setNPrioritizedActions(parseInt(e.target.value, 10))} style={{ width: '80px', padding: '5px' }} />
                                            </div>
                                        </div>
                                    )}

                                    {settingsTab === 'configurations' && (
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>
                                                <label style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Monitoring Factor Thermal Limits</label>
                                                <div style={{ display: 'flex', gap: '5px', alignItems: 'center' }}>
                                                    <input type="number" step="0.01" min="0" max="2" value={monitoringFactor} onChange={e => setMonitoringFactor(parseFloat(e.target.value))} style={{ padding: '6px', width: '80px', border: '1px solid #ccc', borderRadius: '4px' }} />
                                                    <span style={{ fontSize: '0.85rem', color: '#666' }}>Multiplier applied to standard limits (e.g., 0.95)</span>
                                                </div>
                                            </div>
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>
                                                <label style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Lines Monitoring File (Optional)</label>
                                                <div style={{ display: 'flex', gap: '5px' }}>
                                                    <input type="text" value={linesMonitoringPath} onChange={e => setLinesMonitoringPath(e.target.value)} placeholder="Leave empty for IGNORE_LINES_MONITORING=True" style={{ flex: 1, padding: '8px', border: '1px solid #ccc', borderRadius: '4px' }} />
                                                    <button onClick={() => pickPath('file', setLinesMonitoringPath)} style={{ padding: '8px', background: '#7f8c8d', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>📁</button>
                                                </div>
                                            </div>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <label style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Pre-existing Overload Threshold</label>
                                                <input type="number" step="0.01" min="0" max="1" value={preExistingOverloadThreshold} onChange={e => setPreExistingOverloadThreshold(parseFloat(e.target.value))} style={{ width: '80px', padding: '5px', border: '1px solid #ccc', borderRadius: '4px' }} />
                                            </div>
                                            <div style={{ fontSize: '0.75rem', color: '#666', marginTop: '-10px' }}>
                                                Pre-existing overloads excluded from N-1 & max_rho unless worsened by this fraction (default 2%)
                                            </div>
                                        </div>
                                    )}

                                    <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '10px', marginTop: '10px' }}>
                                        <button onClick={handleCloseSettings} style={{ background: '#95a5a6', padding: '8px 20px', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Close</button>
                                        <button onClick={handleApplySettings} style={{ background: '#27ae60', padding: '8px 20px', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Apply</button>
                                    </div>
                                </div>
                            </div>
                        )
                    }

                    <div className="main-content">
                        <div className="action-feed">
                            {/* Target Contingency selector */}
                            {branches.length > 0 && (
                                <div style={{ marginBottom: '10px', padding: '10px 15px', background: 'white', borderRadius: '8px', border: '1px solid #dee2e6', boxShadow: '0 2px 4px rgba(0,0,0,0.05)' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold', display: 'block', marginBottom: '5px' }}>🎯 Select Contingency</label>
                                    <input list="contingencies" value={selectedBranch} onChange={e => setSelectedBranch(e.target.value)} placeholder="Search line/bus..." style={{ width: '100%', padding: '7px 10px', border: '1px solid #ccc', borderRadius: '4px', boxSizing: 'border-box', fontSize: '0.85rem' }} />
                                    <datalist id="contingencies">{branches.map(b => <option key={b} value={b} />)}</datalist>
                                    <button onClick={handleRunAnalysis} disabled={!selectedBranch || analysisLoading} style={{ marginTop: '8px', width: '100%', padding: '8px', background: (!selectedBranch || analysisLoading) ? '#95a5a6' : '#27ae60', color: 'white', border: 'none', borderRadius: '4px', cursor: (!selectedBranch || analysisLoading) ? 'not-allowed' : 'pointer', fontWeight: 'bold', fontSize: '0.85rem' }}>
                                        {analysisLoading ? '⚙️ Running...' : '🚀 Run Analysis'}
                                    </button>
                                </div>
                            )}
                            <div style={{ marginBottom: '15px', padding: '10px 15px', background: 'white', borderRadius: '8px', border: '1px solid #dee2e6', boxShadow: '0 2px 4px rgba(0,0,0,0.05)' }}>
                                <h3 style={{ margin: '0 0 8px 0', fontSize: '15px', display: 'flex', alignItems: 'center', gap: '6px' }}>
                                    <span style={{ color: '#e74c3c' }}>⚠️</span> Overloads
                                </h3>

                                {showMonitoringWarning && totalLinesCount > 0 && (
                                    <div style={{ marginBottom: '10px', padding: '8px 10px', background: '#fff3cd', border: '1px solid #ffeeba', borderRadius: '4px', color: '#856404', fontSize: '0.85rem' }}>
                                        ⚠️ {monitoredLinesCount} out of {totalLinesCount} lines monitored. Monitoring factor applied: {Math.round(monitoringFactor * 100)}%. {Math.round(preExistingOverloadThreshold * 100)}% loading increase threshold for considering worsened overload in N.
                                        <button onClick={() => { handleOpenSettings(); setSettingsTab('configurations'); }} style={{ background: 'none', border: 'none', color: '#0056b3', textDecoration: 'underline', cursor: 'pointer', padding: '0 0 0 5px' }}>Change in settings</button>
                                        <button onClick={() => setShowMonitoringWarning(false)} style={{ float: 'right', background: 'none', border: 'none', fontSize: '16px', lineHeight: 1, color: '#856404', cursor: 'pointer' }} title="Dismiss">&times;</button>
                                    </div>
                                )}

                                <div style={{ fontSize: '13px', display: 'flex', flexDirection: 'column', gap: '6px' }}>
                                    <div style={{
                                        display: 'flex',
                                        alignItems: 'baseline',
                                        gap: '8px',
                                        padding: '6px',
                                        background: nDiagram && nDiagram.lines_overloaded && nDiagram.lines_overloaded.length > 0 ? '#ffe0cc' : 'transparent',
                                        borderLeft: nDiagram && nDiagram.lines_overloaded && nDiagram.lines_overloaded.length > 0 ? '3px solid #ff8c00' : '3px solid transparent',
                                        borderBottom: '1px solid #eee'
                                    }}>
                                        <strong style={{ whiteSpace: 'nowrap' }}>N Overloads:</strong>
                                        <div style={{ display: 'inline', wordBreak: 'break-word' }}>
                                            {nDiagram && nDiagram.lines_overloaded && nDiagram.lines_overloaded.length > 0 ? (
                                                nDiagram.lines_overloaded.map((lvl, i) => (
                                                    <React.Fragment key={lvl}>
                                                        {i > 0 && ', '}
                                                        <button onClick={() => handleAssetClick(null, lvl, 'n')} style={{ background: 'none', border: 'none', cursor: 'pointer', padding: 0, fontSize: 'inherit', color: '#1e40af', fontWeight: 600, textDecoration: 'underline dotted' }}>{lvl}</button>
                                                    </React.Fragment>
                                                ))
                                            ) : (
                                                <span style={{ color: '#888', fontStyle: 'italic' }}>None</span>
                                            )}
                                        </div>
                                    </div>

                                    <div style={{
                                        display: 'flex',
                                        alignItems: 'baseline',
                                        gap: '8px',
                                        padding: '6px',
                                        background: n1Diagram && n1Diagram.lines_overloaded && n1Diagram.lines_overloaded.length > 0 ? '#f8d7da' : 'transparent',
                                        borderLeft: n1Diagram && n1Diagram.lines_overloaded && n1Diagram.lines_overloaded.length > 0 ? '3px solid #dc3545' : '3px solid transparent',
                                        borderBottom: '1px solid #eee'
                                    }}>
                                        <strong style={{ whiteSpace: 'nowrap' }}>N-1 Overloads:</strong>
                                        <div style={{ display: 'inline', wordBreak: 'break-word' }}>
                                            {n1Diagram && n1Diagram.lines_overloaded && n1Diagram.lines_overloaded.length > 0 ? (
                                                n1Diagram.lines_overloaded.map((lvl, i) => (
                                                    <React.Fragment key={lvl}>
                                                        {i > 0 && ', '}
                                                        <button onClick={() => handleAssetClick(null, lvl, 'n-1')} style={{ background: 'none', border: 'none', cursor: 'pointer', padding: 0, fontSize: 'inherit', color: '#1e40af', fontWeight: 600, textDecoration: 'underline dotted' }}>{lvl}</button>
                                                    </React.Fragment>
                                                ))
                                            ) : (
                                                <span style={{ color: '#888', fontStyle: 'italic' }}>None</span>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '10px', position: 'relative' }}>
                                <h3 style={{ margin: 0, flex: 1 }}>Simulated Actions</h3>
                                <button
                                    onClick={handleOpenSearch}
                                    style={{
                                        background: searchOpen ? '#007bff' : '#e9ecef',
                                        color: searchOpen ? 'white' : '#333',
                                        border: 'none',
                                        borderRadius: '6px',
                                        padding: '4px 10px',
                                        cursor: 'pointer',
                                        fontSize: '13px',
                                        fontWeight: 600,
                                    }}
                                >
                                    + Manual Selection
                                </button>

                                {searchOpen && (
                                    <div
                                        ref={searchDropdownRef}
                                        style={{
                                            position: 'absolute',
                                            top: '100%',
                                            right: 0,
                                            left: 0,
                                            zIndex: 100,
                                            backgroundColor: 'white',
                                            border: '1px solid #ccc',
                                            borderRadius: '8px',
                                            boxShadow: '0 4px 16px rgba(0,0,0,0.15)',
                                            marginTop: '4px',
                                            overflow: 'hidden',
                                        }}
                                    >
                                        <div style={{ padding: '8px' }}>
                                            <input
                                                ref={searchInputRef}
                                                type="text"
                                                placeholder="Search action by ID or description..."
                                                value={searchQuery}
                                                onChange={(e) => setSearchQuery(e.target.value)}
                                                style={{
                                                    width: '100%',
                                                    padding: '6px 10px',
                                                    border: '1px solid #ccc',
                                                    borderRadius: '4px',
                                                    fontSize: '13px',
                                                    boxSizing: 'border-box',
                                                }}
                                            />
                                        </div>
                                        <div style={{ padding: '4px 8px', display: 'flex', flexWrap: 'wrap', gap: '6px', borderTop: '1px solid #eee', fontSize: '11px' }}>
                                            {[['disco', 'Disconnections'], ['reco', 'Reconnections'], ['open', 'Open coupling'], ['close', 'Close coupling']].map(([key, label]) => (
                                                <label key={key} style={{ display: 'flex', alignItems: 'center', gap: '3px', cursor: 'pointer', color: '#555' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={typeFilters[key]}
                                                        onChange={(e) => setTypeFilters(prev => ({ ...prev, [key]: e.target.checked }))}
                                                        style={{ margin: 0 }}
                                                    />
                                                    {label}
                                                </label>
                                            ))}
                                        </div>
                                        {searchError && (
                                            <div style={{ padding: '6px 8px', fontSize: '12px', color: '#dc3545', borderTop: '1px solid #eee' }}>
                                                {searchError}
                                            </div>
                                        )}
                                        <div style={{ maxHeight: '250px', overflowY: 'auto' }}>
                                            {loadingAvailableActions ? (
                                                <div style={{ padding: '10px', textAlign: 'center', color: '#888', fontSize: '13px' }}>
                                                    Loading actions...
                                                </div>
                                            ) : (
                                                <>
                                                    {/* Action Scores Table */}
                                                    {scoredActionsList.length > 0 && !searchQuery && (
                                                        <div style={{ padding: '0 8px', marginBottom: '8px' }}>
                                                            <div style={{ fontSize: '12px', fontWeight: 600, color: '#555', marginBottom: '4px' }}>
                                                                Scored Actions
                                                            </div>
                                                            {Array.from(new Set(scoredActionsList.map(item => item.type))).map(type => {
                                                                const typeData = result?.action_scores?.[type] || {};
                                                                const scoresKeys = Object.keys(typeData.scores || {});
                                                                const paramsKeys = Object.keys(typeData.params || {});
                                                                const isPerActionParams = paramsKeys.length > 0 && paramsKeys.some(k => scoresKeys.includes(k));
                                                                const globalParams = isPerActionParams ? null : (paramsKeys.length > 0 ? typeData.params : null);

                                                                return (
                                                                    <div key={type} style={{ marginBottom: '8px' }}>
                                                                        <div style={{ fontSize: '11px', fontWeight: 600, color: '#0056b3', backgroundColor: '#e9ecef', padding: '2px 6px', borderRadius: '4px 4px 0 0', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                            <span>{type.replace('_', ' ').toUpperCase()}</span>
                                                                            {globalParams && (
                                                                                <span
                                                                                    style={{ color: '#6c757d', fontSize: '12px', cursor: 'help', marginLeft: '6px' }}
                                                                                    onMouseEnter={(e) => showScoreTooltip(e, React.createElement(React.Fragment, null,
                                                                                        React.createElement('div', { style: { fontWeight: 700, marginBottom: '2px', borderBottom: '1px solid #555', paddingBottom: '2px' } }, 'Scoring Parameters'),
                                                                                        ...Object.entries(globalParams).map(([k, v]) =>
                                                                                            React.createElement('div', { key: k },
                                                                                                React.createElement('span', { style: { color: '#adb5bd' } }, k + ':'),
                                                                                                ' ' + (typeof v === 'object' ? JSON.stringify(v) : String(v))
                                                                                            )
                                                                                        )
                                                                                    ))}
                                                                                    onMouseLeave={hideScoreTooltip}
                                                                                >ⓘ</span>
                                                                            )}
                                                                        </div>
                                                                        <table style={{ width: '100%', fontSize: '11px', borderCollapse: 'collapse', border: '1px solid #e9ecef', borderTop: 'none' }}>
                                                                            <thead>
                                                                                <tr style={{ background: '#f8f9fa', borderBottom: '1px solid #ddd' }}>
                                                                                    <th style={{ textAlign: 'left', padding: '4px 6px', width: '70%' }}>Action</th>
                                                                                    <th style={{ textAlign: 'right', padding: '4px 6px', width: '30%' }}>Score</th>
                                                                                </tr>
                                                                            </thead>
                                                                            <tbody>
                                                                                {scoredActionsList.filter(item => item.type === type).map(item => {
                                                                                    const isComputed = !!(result?.actions && result.actions[item.actionId]);
                                                                                    return (
                                                                                        <tr key={item.actionId}
                                                                                            onClick={() => !isComputed && handleAddManualAction(item.actionId)}
                                                                                            style={{
                                                                                                borderBottom: '1px solid #eee',
                                                                                                cursor: (isComputed || simulatingActionId) ? 'not-allowed' : 'pointer',
                                                                                                color: isComputed ? '#888' : 'inherit',
                                                                                                opacity: simulatingActionId === item.actionId ? 0.7 : 1,
                                                                                                background: simulatingActionId === item.actionId ? '#e7f1ff' : 'transparent',
                                                                                            }}>
                                                                                            <td style={{ padding: '4px 6px', fontWeight: 600, display: 'flex', alignItems: 'center' }}>
                                                                                                {item.actionId}
                                                                                                {isComputed && <span style={{ marginLeft: '4px', background: '#28a745', color: '#fff', padding: '2px 4px', borderRadius: '4px', fontSize: '9px', opacity: 0.8 }}>computed</span>}
                                                                                                {isPerActionParams && typeData.params[item.actionId] && (
                                                                                                    <span
                                                                                                        style={{ color: '#6c757d', fontSize: '12px', cursor: 'help', marginLeft: '6px' }}
                                                                                                        onClick={(e) => e.stopPropagation()}
                                                                                                        onMouseEnter={(e) => showScoreTooltip(e, React.createElement(React.Fragment, null,
                                                                                                            React.createElement('div', { style: { fontWeight: 700, marginBottom: '2px', borderBottom: '1px solid #555', paddingBottom: '2px' } }, 'Parameters'),
                                                                                                            ...Object.entries(typeData.params[item.actionId]).map(([k, v]) =>
                                                                                                                React.createElement('div', { key: k },
                                                                                                                    React.createElement('span', { style: { color: '#adb5bd' } }, k + ':'),
                                                                                                                    ' ' + (typeof v === 'object' ? JSON.stringify(v) : String(v))
                                                                                                                )
                                                                                                            )
                                                                                                        ))}
                                                                                                        onMouseLeave={hideScoreTooltip}
                                                                                                    >ⓘ</span>
                                                                                                )}
                                                                                            </td>
                                                                                            <td style={{ padding: '4px 6px', textAlign: 'right', fontFamily: 'monospace' }}>
                                                                                                {item.score.toFixed(2)}
                                                                                            </td>
                                                                                        </tr>
                                                                                    );
                                                                                })}
                                                                            </tbody>
                                                                        </table>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    )}

                                                    {/* Search Results */}
                                                    {(!searchQuery && scoredActionsList.length === 0 && filteredSearchActions.length === 0) && (
                                                        <div style={{ padding: '10px', textAlign: 'center', color: '#888', fontSize: '13px' }}>
                                                            All actions already added
                                                        </div>
                                                    )}
                                                    {(searchQuery && filteredSearchActions.length === 0) && (
                                                        <div style={{ padding: '10px', textAlign: 'center', color: '#888', fontSize: '13px' }}>
                                                            No matching actions
                                                        </div>
                                                    )}
                                                    {((!searchQuery && scoredActionsList.length === 0) || searchQuery) && filteredSearchActions.map(a => (
                                                        <div
                                                            key={a.id}
                                                            onClick={() => handleAddManualAction(a.id)}
                                                            style={{
                                                                padding: '6px 10px',
                                                                cursor: simulatingActionId ? 'wait' : 'pointer',
                                                                borderTop: '1px solid #eee',
                                                                backgroundColor: simulatingActionId === a.id ? '#e7f1ff' : 'transparent',
                                                                opacity: simulatingActionId && simulatingActionId !== a.id ? 0.5 : 1,
                                                            }}
                                                            onMouseEnter={(e) => { if (!simulatingActionId) e.currentTarget.style.backgroundColor = '#f0f0f0'; }}
                                                            onMouseLeave={(e) => { if (simulatingActionId !== a.id) e.currentTarget.style.backgroundColor = 'transparent'; }}
                                                        >
                                                            <div style={{ fontWeight: 600, fontSize: '12px', color: '#333' }}>
                                                                {simulatingActionId === a.id ? '⏳ Simulating...' : a.id}
                                                            </div>
                                                            {a.description && (
                                                                <div style={{ fontSize: '11px', color: '#777', marginTop: '2px' }}>
                                                                    {a.description}
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                </>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>


                            {/* View mode toggle - only visible when an action is selected */}

                            {/* Processing indicator during analysis */}
                            {analysisLoading && (
                                <div style={{ padding: '12px', textAlign: 'center', color: '#856404', background: '#fff3cd', borderRadius: '8px', margin: '8px 0', fontSize: '13px', fontWeight: 600 }}>
                                    ⚙️ Processing analysis...
                                </div>
                            )}

                            {/* Display prioritized actions button */}
                            {pendingAnalysisResult && !analysisLoading && (
                                <button
                                    onClick={handleDisplayPrioritizedActions}
                                    style={{
                                        width: '100%',
                                        padding: '10px 16px',
                                        margin: '8px 0',
                                        background: 'linear-gradient(135deg, #27ae60, #2ecc71)',
                                        color: 'white',
                                        border: 'none',
                                        borderRadius: '8px',
                                        cursor: 'pointer',
                                        fontSize: '14px',
                                        fontWeight: 700,
                                        boxShadow: '0 2px 8px rgba(39,174,96,0.3)',
                                        transition: 'transform 0.1s',
                                    }}
                                    onMouseEnter={(e) => e.target.style.transform = 'scale(1.02)'}
                                    onMouseLeave={(e) => e.target.style.transform = 'scale(1)'}
                                >
                                    📊 Display {Object.keys(pendingAnalysisResult.actions || {}).length} prioritized actions
                                </button>
                            )}

                            {result?.actions && Object.keys(result.actions).length > 0 ? (
                                Object.entries(result.actions).sort(([, a], [, b]) => (a.max_rho ?? 999) - (b.max_rho ?? 999)).map(([id, details], index) => {
                                    const maxRhoPct = details.max_rho != null ? (details.max_rho * 100).toFixed(1) : null;
                                    const overloadedLines = result.lines_overloaded || [];
                                    // Tri-color severity: red (>100%), orange (>90%), green (<=90%)
                                    const severity = details.max_rho != null
                                        ? (details.max_rho > monitoringFactor ? 'red' : details.max_rho > (monitoringFactor - 0.05) ? 'orange' : 'green')
                                        : (details.is_rho_reduction ? 'green' : 'red');
                                    const severityColors = {
                                        green: { border: '#28a745', badgeBg: '#d4edda', badgeText: '#155724', label: 'Solves overload' },
                                        orange: { border: '#f0ad4e', badgeBg: '#fff3cd', badgeText: '#856404', label: 'Solved — low margin' },
                                        red: { border: '#dc3545', badgeBg: '#f8d7da', badgeText: '#721c24', label: details.is_rho_reduction ? 'Still overloaded' : 'No reduction' }
                                    };
                                    const sc = severityColors[severity];
                                    const clickableLinkStyle = { background: 'none', border: 'none', cursor: 'pointer', padding: 0, fontSize: 'inherit', color: '#1e40af', fontWeight: 600, textDecoration: 'underline dotted' };
                                    const renderRho = (arr, tab) => {
                                        if (!arr || arr.length === 0) return '—';
                                        return arr.map((v, i) => {
                                            const lineName = overloadedLines[i] || `line ${i}`;
                                            return (
                                                <React.Fragment key={i}>
                                                    {i > 0 && ', '}
                                                    <button style={clickableLinkStyle} title={`Zoom to ${lineName}`}
                                                        onClick={(e) => { e.stopPropagation(); handleAssetClick(id, lineName, tab); }}
                                                    >{lineName}</button>
                                                    {`: ${(v * 100).toFixed(1)}%`}
                                                </React.Fragment>
                                            );
                                        });
                                    };
                                    const isSelected = selectedActionId === id;
                                    return (
                                        <div key={id} className="card" onClick={() => handleActionSelect(id)} style={{
                                            borderLeftColor: isSelected ? '#007bff' : sc.border,
                                            cursor: 'pointer',
                                            background: isSelected ? '#e7f1ff' : 'white',
                                            boxShadow: isSelected ? '0 0 0 2px rgba(0,123,255,0.3), 0 2px 8px rgba(0,0,0,0.15)' : '0 2px 4px rgba(0,0,0,0.1)',
                                            transition: 'all 0.15s ease'
                                        }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <h4 style={{ margin: 0, color: isSelected ? '#0056b3' : undefined }}>#{index + 1} — {id}</h4>
                                                <div style={{ display: 'flex', gap: '5px', alignItems: 'center' }}>
                                                    {isSelected && (
                                                        <span style={{ fontSize: '10px', fontWeight: 600, padding: '2px 6px', borderRadius: '4px', background: '#007bff', color: 'white' }}>
                                                            VIEWING
                                                        </span>
                                                    )}
                                                    <span style={{ fontSize: '11px', fontWeight: 600, padding: '2px 8px', borderRadius: '12px', background: sc.badgeBg, color: sc.badgeText }}>
                                                        {sc.label}
                                                    </span>
                                                </div>
                                            </div>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', gap: '8px', margin: '4px 0 5px' }}>
                                                <p style={{ fontSize: '13px', margin: 0, flex: 1 }}>{details.description_unitaire}</p>
                                                {(() => {
                                                    const nodeMeta = nMetaIndex && nMetaIndex.nodesByEquipmentId;
                                                    const edgeMeta = nMetaIndex && nMetaIndex.edgesByEquipmentId;
                                                    const vlName = nodeMeta ? getActionTargetVoltageLevel(details, id, nodeMeta) : null;
                                                    if (vlName) {
                                                        return (
                                                            <button
                                                                style={{ padding: '2px 7px', borderRadius: '4px', border: 'none', cursor: 'pointer', fontSize: '11px', fontWeight: 600, backgroundColor: '#d1fae5', color: '#065f46', textDecoration: 'underline dotted', flexShrink: 0 }}
                                                                title={`Click: zoom to ${vlName} | Double-click: open focused diagram`}
                                                                onClick={(e) => { e.stopPropagation(); handleAssetClick(id, vlName, 'action'); }}
                                                                onDoubleClick={(e) => { e.stopPropagation(); handleVlDoubleClick(id, vlName); }}>
                                                                {vlName}
                                                            </button>
                                                        );
                                                    }
                                                    const badgeBtn = (name, bg, color, title) => (
                                                        <button key={name}
                                                            style={{ padding: '2px 7px', borderRadius: '4px', border: 'none', cursor: 'pointer', fontSize: '11px', fontWeight: 600, textDecoration: 'underline dotted', flexShrink: 0, backgroundColor: bg, color }}
                                                            title={title}
                                                            onClick={(e) => { e.stopPropagation(); handleAssetClick(id, name, 'action'); }}>
                                                            {name}
                                                        </button>
                                                    );
                                                    const lineNames = edgeMeta
                                                        ? getActionTargetLines(details, id, edgeMeta)
                                                        : Array.from(new Set([
                                                            ...Object.keys(details.action_topology?.lines_ex_bus || {}),
                                                            ...Object.keys(details.action_topology?.lines_or_bus || {}),
                                                        ]));
                                                    if (lineNames.length > 0) {
                                                        return (
                                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px', flexShrink: 0 }}>
                                                                {lineNames.map(name => badgeBtn(name, '#dbeafe', '#1e40af', `Zoom to line ${name} in action visualization`))}
                                                            </div>
                                                        );
                                                    }
                                                    // Fallback: gen/load equipment names from topology
                                                    const topo = details.action_topology;
                                                    const equipNames = [
                                                        ...Object.keys(topo?.gens_bus || {}),
                                                        ...Object.keys(topo?.loads_bus || {}),
                                                    ];
                                                    if (equipNames.length > 0) {
                                                        return (
                                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px', flexShrink: 0 }}>
                                                                {equipNames.map(name => badgeBtn(name, '#fef3c7', '#92400e', `Zoom to ${name} in action visualization`))}
                                                            </div>
                                                        );
                                                    }
                                                    return null;
                                                })()}
                                            </div>
                                            <div style={{ fontSize: '12px', background: isSelected ? '#dce8f7' : '#f8f9fa', padding: '5px', marginTop: '5px' }}>
                                                <div>Rho before: {renderRho(details.rho_before, 'n-1')}</div>
                                                <div>Rho after: {renderRho(details.rho_after, 'action')}</div>
                                                {maxRhoPct != null && (
                                                    <div style={{ marginTop: '3px' }}>
                                                        Max rho: <strong style={{ color: sc.border }}>{maxRhoPct}%</strong>
                                                        {details.max_rho_line && (
                                                            <span style={{ color: '#888' }}> on <button
                                                                style={{ ...clickableLinkStyle, color: '#888' }}
                                                                title={`Zoom to ${details.max_rho_line}`}
                                                                onClick={(e) => { e.stopPropagation(); handleAssetClick(id, details.max_rho_line, 'action'); }}
                                                            >{details.max_rho_line}</button></span>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })
                            ) : !analysisLoading && !pendingAnalysisResult && <p style={{ color: '#666', fontStyle: 'italic' }}>No actions available.</p>}

                            {/* Fixed-position tooltip rendered outside any overflow context */}
                            {scoreTooltip && (
                                <div style={{
                                    position: 'fixed',
                                    top: scoreTooltip.y,
                                    left: scoreTooltip.x,
                                    zIndex: 99999,
                                    backgroundColor: '#343a40',
                                    color: '#fff',
                                    textAlign: 'left',
                                    borderRadius: '4px',
                                    padding: '6px 8px',
                                    fontSize: '10px',
                                    fontWeight: 'normal',
                                    whiteSpace: 'nowrap',
                                    boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
                                    lineHeight: 1.4,
                                    pointerEvents: 'none',
                                    maxWidth: '90vw',
                                }}>
                                    {scoreTooltip.content}
                                </div>
                            )}
                        </div>
                        <div className="visualization" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div style={{ display: 'flex', borderBottom: '1px solid #ccc' }}>
                                <button
                                    onClick={() => setActiveTab('n')}
                                    style={{ flex: 1, borderRadius: 0, border: 'none', background: activeTab === 'n' ? 'white' : '#ecf0f1', color: activeTab === 'n' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'n' ? '3px solid #3498db' : 'none', cursor: 'pointer', padding: '8px 15px', fontWeight: activeTab === 'n' ? 'bold' : 400 }}
                                >
                                    Network (N)
                                </button>
                                <button
                                    onClick={() => setActiveTab('n-1')}
                                    style={{ flex: 1, borderRadius: 0, border: 'none', background: activeTab === 'n-1' ? 'white' : '#ecf0f1', color: activeTab === 'n-1' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'n-1' ? '3px solid #e74c3c' : 'none', cursor: 'pointer', padding: '8px 15px', fontWeight: activeTab === 'n-1' ? 'bold' : 400 }}
                                >
                                    Contingency (N-1)
                                </button>
                                {selectedActionId && (
                                    <button
                                        onClick={() => setActiveTab('action')}
                                        style={{ flex: 1, borderRadius: 0, border: 'none', background: activeTab === 'action' ? 'white' : '#ecf0f1', color: activeTab === 'action' ? '#0056b3' : '#7f8c8d', borderBottom: activeTab === 'action' ? '3px solid #007bff' : 'none', cursor: 'pointer', padding: '8px 15px', fontWeight: activeTab === 'action' ? 'bold' : 400 }}
                                    >
                                        Action: {selectedActionId}
                                    </button>
                                )}
                                {analysisRan && result && (
                                    <button
                                        onClick={() => setActiveTab('overflow')}
                                        style={{ flex: 1, borderRadius: 0, border: 'none', background: activeTab === 'overflow' ? 'white' : '#ecf0f1', color: activeTab === 'overflow' ? '#2c3e50' : '#7f8c8d', borderBottom: activeTab === 'overflow' ? '3px solid #27ae60' : 'none', cursor: 'pointer', padding: '8px 15px', fontWeight: activeTab === 'overflow' ? 'bold' : 400 }}
                                    >
                                        Overflow Analysis
                                    </button>
                                )}

                            </div>
                            <div style={{ flex: 1, position: 'relative', overflow: 'hidden' }}>
                                {/* View Mode Overlay */}
                                {(activeTab !== 'overflow' && activeTab !== 'n' && (
                                    (activeTab === 'n-1' && !!n1Diagram?.svg) ||
                                    (activeTab === 'action' && !!actionDiagram?.svg)
                                )) && (
                                        <div style={{
                                            position: 'absolute',
                                            top: '10px',
                                            right: '75px',
                                            zIndex: 100,
                                            display: 'flex',
                                            borderRadius: '6px',
                                            overflow: 'hidden',
                                            border: '1px solid #ccc',
                                            boxShadow: '0 2px 5px rgba(0,0,0,0.15)',
                                            fontSize: '12px',
                                            fontWeight: 600,
                                            backgroundColor: '#fff',
                                        }}>
                                            <button
                                                onClick={() => setActionViewMode('network')}
                                                style={{
                                                    padding: '4px 12px', border: 'none', cursor: 'pointer',
                                                    backgroundColor: actionViewMode === 'network' ? '#007bff' : '#fff',
                                                    color: actionViewMode === 'network' ? '#fff' : '#555',
                                                    transition: 'all 0.15s ease'
                                                }}
                                            >
                                                Flows
                                            </button>
                                            <button
                                                onClick={() => setActionViewMode('delta')}
                                                style={{
                                                    padding: '4px 12px', border: 'none', borderLeft: '1px solid #ccc', cursor: 'pointer',
                                                    backgroundColor: actionViewMode === 'delta' ? '#007bff' : '#fff',
                                                    color: actionViewMode === 'delta' ? '#fff' : '#555',
                                                    transition: 'all 0.15s ease'
                                                }}
                                            >
                                                Impacts
                                            </button>
                                        </div>
                                    )}

                                {/* Bottom-left overlay: Zoom + Inspect */}
                                {activeTab !== 'overflow' && (
                                    <div style={{
                                        position: 'absolute',
                                        bottom: '12px',
                                        left: '12px',
                                        zIndex: 100,
                                        display: 'flex',
                                        flexDirection: 'column',
                                        gap: '6px',
                                        nItems: 'flex-start',
                                    }}>
                                        <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                            <button onClick={handleManualZoomIn} style={{
                                                background: 'white', color: '#333', border: '1px solid #ccc',
                                                borderRadius: '4px', padding: '5px 12px', cursor: 'pointer',
                                                fontSize: '14px', fontWeight: 600, boxShadow: '0 2px 5px rgba(0,0,0,0.15)',
                                            }} title="Zoom In">+</button>
                                            <button onClick={handleManualReset} style={{
                                                background: 'white', color: '#333', border: '1px solid #ccc',
                                                borderRadius: '4px', padding: '5px 14px', cursor: 'pointer',
                                                fontSize: '12px', fontWeight: 600, boxShadow: '0 2px 5px rgba(0,0,0,0.15)',
                                            }}>🔍 Unzoom</button>
                                            <button onClick={handleManualZoomOut} style={{
                                                background: 'white', color: '#333', border: '1px solid #ccc',
                                                borderRadius: '4px', padding: '5px 12px', cursor: 'pointer',
                                                fontSize: '14px', fontWeight: 600, boxShadow: '0 2px 5px rgba(0,0,0,0.15)',
                                            }} title="Zoom Out">-</button>
                                        </div>
                                        {branches.length > 0 && (
                                            <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                                <input
                                                    list="inspectables"
                                                    value={inspectQuery}
                                                    onChange={e => setInspectQuery(e.target.value)}
                                                    placeholder="🔍 Inspect..."
                                                    style={{
                                                        padding: '5px 10px',
                                                        border: inspectQuery ? '2px solid #3498db' : '1px solid #ccc',
                                                        borderRadius: '4px',
                                                        fontSize: '12px',
                                                        width: '180px',
                                                        boxShadow: '0 2px 5px rgba(0,0,0,0.15)',
                                                        background: 'white',
                                                    }}
                                                />
                                                <datalist id="inspectables">{inspectableItems.map(b => <option key={b} value={b} />)}</datalist>
                                                {inspectQuery && (
                                                    <button onClick={() => setInspectQuery('')} style={{ background: '#e74c3c', color: 'white', border: 'none', borderRadius: '4px', padding: '4px 8px', cursor: 'pointer', fontSize: '12px', boxShadow: '0 2px 5px rgba(0,0,0,0.15)' }} title="Clear">
                                                        ✖
                                                    </button>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                                {renderVisualization()}
                            </div>
                        </div>
                    </div>
                    {error && <div style={{ position: 'fixed', bottom: 20, right: 20, background: '#e74c3c', color: 'white', padding: '10px 20px', borderRadius: '4px', boxShadow: '0 2px 10px rgba(0,0,0,0.2)' }}>❌ {error}</div>}
                </div >
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>